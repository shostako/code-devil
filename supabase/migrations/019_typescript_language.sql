-- 019: TypeScript言語追加（70件）
-- 型システム特化、JavaScriptとの差分を明確に

-- ===========================================
-- TypeScript 言語登録
-- ===========================================
INSERT INTO languages (id, slug, name, icon_url, description) VALUES
  ('44444444-4444-4444-4444-444444444444', 'typescript', 'TypeScript', '/icons/typescript.svg', 'JavaScriptに静的型付けを追加した言語。型安全性とIDEサポートの向上が魅力。');

-- ===========================================
-- TypeScript カテゴリ
-- ===========================================
INSERT INTO categories (id, language_id, slug, name, sort_order) VALUES
  ('a0111111-1111-1111-1111-111111111111', '44444444-4444-4444-4444-444444444444', 'type-basics', '型の基礎', 1),
  ('a0222222-2222-2222-2222-222222222222', '44444444-4444-4444-4444-444444444444', 'generics', 'ジェネリクス', 2),
  ('a0333333-3333-3333-3333-333333333333', '44444444-4444-4444-4444-444444444444', 'type-guards', '型ガード', 3),
  ('a0444444-4444-4444-4444-444444444444', '44444444-4444-4444-4444-444444444444', 'utility-types', 'ユーティリティ型', 4),
  ('a0555555-5555-5555-5555-555555555555', '44444444-4444-4444-4444-444444444444', 'advanced', '高度な型', 5);

-- ===========================================
-- TypeScript エントリ（70件）
-- ===========================================

-- =====================
-- 型の基礎 (20件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('interface', 'interface', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'オブジェクトの形を定義する',
'interfaceはオブジェクトの構造を定義するTypeScriptの基本構文。プロパティの名前と型を指定し、オブジェクトがその形に従うことを保証します。',
'interface User {\n  id: number;\n  name: string;\n  email?: string; // 省略可能\n}\n\nconst user: User = {\n  id: 1,\n  name: "田中"\n};',
'契約書作成係',
ARRAY['typeとどっち使うか論争は永遠のテーマ', '宣言マージで同名interfaceが合体する罠', 'extendsで継承できるが多重継承は地獄', 'React Propsはinterfaceで定義する派が多い'],
'型の設計図',
ARRAY['オブジェクトの「形」を事前に定義できる', '?をつけるとオプショナルプロパティになる', 'extendsで既存のinterfaceを拡張可能', 'IDEの補完が効くようになる最初の一歩'],
true),

('type-alias', 'type', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'型に別名をつける',
'type aliasは既存の型に別名をつけたり、複雑な型を定義するための構文。interfaceより柔軟で、プリミティブ型やunion型にも名前をつけられます。',
'type ID = string | number;\ntype Point = { x: number; y: number };\ntype Callback = (data: string) => void;\n\nconst id: ID = "abc123";',
'型の名付け親',
ARRAY['interfaceと違って同名で宣言マージされない', 'union/intersection/タプルにはtypeを使う', '再帰型も定義できるが無限ループに注意', 'type vs interfaceの宗教戦争に巻き込まれるな'],
'型のニックネーム',
ARRAY['複雑な型に分かりやすい名前をつけられる', 'プリミティブ型にも別名をつけられる（ID = stringなど）', 'union型やタプル型を定義するならtype一択', '|で複数の型を組み合わせられる'],
true),

('union-type', 'Union型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'複数の型のいずれか',
'Union型は「AまたはB」という型を表現。|で複数の型を組み合わせ、値がそのいずれかであることを示します。',
'type Status = "pending" | "success" | "error";\ntype ID = string | number;\n\nfunction printId(id: ID) {\n  if (typeof id === "string") {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}',
'優柔不断な型',
ARRAY['nullableを表現するのに便利 string | null', '絞り込み(narrowing)しないと使えないメソッドがある', 'リテラル型と組み合わせて列挙を表現', 'anyにしたくなったらまずunionを検討しろ'],
'「どちらでもOK」を表現',
ARRAY['複数の型を|で繋いで「いずれかの型」を表現', '型ガード（typeofなど）で絞り込んでから操作する', 'null | undefinedを許容する型を作る定番パターン', 'enumより柔軟なリテラルunion型が人気'],
true),

('intersection-type', 'Intersection型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'複数の型を合成',
'Intersection型は「AかつB」という型を表現。&で複数の型を組み合わせ、すべての型のプロパティを持つ型を作ります。',
'type HasName = { name: string };\ntype HasAge = { age: number };\ntype Person = HasName & HasAge;\n\nconst person: Person = {\n  name: "田中",\n  age: 30\n};',
'型の合体技',
ARRAY['ミックスイン的なパターンで使う', '同名プロパティがある場合の挙動に注意', 'neverになる組み合わせもある（string & number）', 'interfaceのextendsより柔軟だが読みにくくなりがち'],
'型を足し算する',
ARRAY['複数の型を&で合成して新しい型を作る', '両方の型のプロパティをすべて持つ必要がある', 'ミックスイン的に機能を追加していくパターンで活躍', 'Omitと組み合わせて一部を上書きする技もある'],
true),

('literal-type', 'リテラル型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'特定の値だけを許容',
'リテラル型は特定の値そのものを型として扱う。文字列、数値、真偽値のリテラルを型として使用できます。',
'type Direction = "north" | "south" | "east" | "west";\ntype DiceValue = 1 | 2 | 3 | 4 | 5 | 6;\ntype Bool = true | false;\n\nlet dir: Direction = "north"; // OK\n// dir = "up"; // エラー',
'選択肢限定マン',
ARRAY['enumの代わりにこっちを使う派が増加中', 'as constでリテラル型を推論させる', '関数の戻り値を特定の値に限定できる', 'typoを防ぐ最強の防御策'],
'値を型として扱う',
ARRAY['特定の文字列や数値だけを許容する型を作れる', 'enumより軽量でJavaScriptに影響しない', 'unionと組み合わせて選択肢を定義', 'IDEでの補完が効くのでtypo防止に最適'],
true),

('tuple-type', 'タプル型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'固定長で型が決まった配列',
'タプル型は要素数と各要素の型が固定された配列。通常の配列と違い、位置ごとに異なる型を持てます。',
'type Point = [number, number];\ntype NameAge = [string, number];\n\nconst point: Point = [10, 20];\nconst person: NameAge = ["田中", 30];\n\n// 分割代入と相性が良い\nconst [name, age] = person;',
'配列のお堅い親戚',
ARRAY['useStateの戻り値がタプルの典型例', 'push()で要素追加できてしまう罠がある', 'readonly tupleにしないと安心できない', '可変長タプル[...T]という黒魔術もある'],
'順番と型が決まった配列',
ARRAY['各位置の型が決まっているので安全', 'React Hooksの戻り値でおなじみの形式', '分割代入でスッキリ受け取れる', '[type, type?]でオプショナルな要素も定義可能'],
true),

('any-type', 'any型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'型チェックを無効化',
'any型は何でも許容する型。型チェックをバイパスするため、TypeScriptの恩恵を放棄することになります。',
'let value: any = "hello";\nvalue = 123;      // OK\nvalue = true;     // OK\nvalue.foo.bar();  // コンパイルは通るが実行時エラーの可能性',
'型安全の敵',
ARRAY['anyを使った瞬間、TypeScriptを使う意味が半減', 'eslintの@typescript-eslint/no-explicit-anyは必須', 'unknownで代替できないか検討しろ', '緊急避難用であって常用するものではない'],
'最後の手段',
ARRAY['どうしても型が分からない時の避難所', 'ただし使いすぎると型安全性が失われる', 'unknownで代替できないか先に検討', 'JSからの移行時に一時的に使うケースが多い'],
true),

('unknown-type', 'unknown型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'安全なany',
'unknown型はanyの安全版。何でも代入できるが、使用前に型チェックが必要です。',
'let value: unknown = "hello";\n\n// そのままでは使えない\n// value.toUpperCase(); // エラー\n\n// 型を絞り込めばOK\nif (typeof value === "string") {\n  console.log(value.toUpperCase());\n}',
'疑い深い型',
ARRAY['anyを使いたくなったらまずunknownを検討', '外部APIのレスポンス型に最適', '型ガードで絞り込まないと何もできない', 'catchのエラーはunknownがデフォルト（TS4.4+）'],
'慎重派のany',
ARRAY['何でも受け入れるが、使う前に型チェックが必要', '外部からのデータを安全に扱うのに最適', 'anyより安全で、型ガードを強制してくれる', 'try-catchのエラー変数にも使える'],
true),

('never-type', 'never型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'advanced',
'ありえない型',
'never型は「絶対に発生しない値」を表す型。関数が正常終了しない場合や、到達不能なコードを示します。',
'function throwError(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n\n// 網羅性チェックに活用\ntype Shape = "circle" | "square";\nfunction getArea(shape: Shape) {\n  switch (shape) {\n    case "circle": return 1;\n    case "square": return 2;\n    default:\n      const _exhaustive: never = shape; // 全パターン網羅を強制\n      return _exhaustive;\n  }\n}',
'存在しない型',
ARRAY['switch文の網羅性チェックに使う黒魔術', 'throw専用関数やwhile(true)の戻り値型', 'union型から型を除外した結果neverになることも', '型システムの底辺に位置する型'],
'「絶対にない」を表現',
ARRAY['関数が絶対に値を返さないことを示す', 'switch文の網羅性チェックに活用できる', '無限ループやthrowする関数の戻り値型', '型の世界の「ありえない」を表現'],
true),

('void-type', 'void型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'戻り値がない',
'void型は関数が値を返さないことを示す型。undefinedに似ているが、戻り値がないことを明示的に表現します。',
'function greet(name: string): void {\n  console.log(`Hello, ${name}`);\n  // return不要（またはreturn;のみ）\n}\n\n// コールバックの型定義で頻出\ntype Callback = (data: string) => void;',
'返事しない関数',
ARRAY['undefinedとの違いを説明できると中級者', 'コールバック関数の戻り値はvoidが安全', 'void演算子とは別物', 'Promiseと絡むと罠がある'],
'「何も返さない」宣言',
ARRAY['関数が明示的に値を返さないことを示す', 'console.logのような副作用だけの関数に', 'コールバック関数の型定義でよく使う', 'return文を書いても書かなくてもOK'],
true),

('null-undefined', 'null / undefined', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'値が存在しないことを表す',
'nullとundefinedは「値がない」ことを表す型。strictNullChecksを有効にすると、これらを明示的に扱う必要があります。',
'let name: string | null = null;\nlet age: number | undefined = undefined;\n\n// strictNullChecksがtrueの場合\nfunction greet(name: string | null) {\n  if (name !== null) {\n    console.log(name.toUpperCase()); // 絞り込み後は安全\n  }\n}',
'虚無の双子',
ARRAY['strictNullChecks: trueは必須設定', 'nullは意図的な空、undefinedは未定義という使い分けもある', '??演算子でデフォルト値を設定', 'undefinedとnullの違いを聞かれると困る'],
'「値がない」を表現',
ARRAY['strictNullChecksで安全に扱える', 'union型でnullableを表現: string | null', '??（nullish coalescing）でデフォルト値を設定', '?.（optional chaining）と組み合わせると便利'],
true),

('object-type', 'object型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'非プリミティブ型',
'object型はプリミティブ型（string, number, boolean等）以外のすべてを表す型。ただし、具体的なプロパティの情報は持ちません。',
'// 具体的なオブジェクト型\nconst user: { name: string; age: number } = {\n  name: "田中",\n  age: 30\n};\n\n// object型は抽象的すぎて使いにくい\nfunction process(obj: object) {\n  // obj.nameはエラー（プロパティが不明）\n}',
'曖昧なオブジェクト',
ARRAY['object型は使い道がほぼない', '具体的な型を定義するかRecordを使え', 'Object（大文字）はさらに罠が多い', '{}型は「プロパティなし」ではなく「何でもOK」に近い'],
'プリミティブ以外すべて',
ARRAY['具体的なプロパティを指定したほうが安全', 'interfaceやtypeで具体的な形を定義しよう', 'Record<string, unknown>で任意のオブジェクトを表現', '{ }（空オブジェクト型）とは意味が違う'],
true),

('array-type', '配列型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'同じ型の要素の配列',
'配列型は同じ型の要素を持つ配列を表現。T[]またはArray<T>の形式で書けます。',
'const numbers: number[] = [1, 2, 3];\nconst strings: Array<string> = ["a", "b", "c"];\n\n// readonly配列\nconst frozen: readonly number[] = [1, 2, 3];\n// frozen.push(4); // エラー\n\n// 混合型配列\nconst mixed: (string | number)[] = [1, "two", 3];',
'同族の集まり',
ARRAY['T[]とArray<T>は同じ意味、好みの問題', 'readonlyつけないと破壊的操作が可能', 'タプルと混同するな', 'mapやfilterの戻り値型は自動推論される'],
'型付き配列',
ARRAY['number[]で数値の配列を表現', 'Array<T>の書き方でも同じ意味', 'readonly配列で不変性を保証', 'union型の配列も定義可能'],
true),

('function-type', '関数型', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'関数のシグネチャを定義',
'関数型は引数と戻り値の型を定義。アロー関数形式で書くのが一般的です。',
'type Greet = (name: string) => string;\ntype Calculate = (a: number, b: number) => number;\n\nconst greet: Greet = (name) => `Hello, ${name}`;\nconst add: Calculate = (a, b) => a + b;\n\n// コールシグネチャでも書ける\ninterface ClickHandler {\n  (event: MouseEvent): void;\n}',
'関数の型紙',
ARRAY['コールバック関数の型定義で必須', 'オーバーロードの型定義は複雑', 'ジェネリック関数型もある', '引数名は型の一部ではないが可読性のために書く'],
'関数の設計図',
ARRAY['(引数) => 戻り値 の形式で関数型を定義', 'コールバック関数の型を明示できる', '引数の型と戻り値の型を両方指定', 'ジェネリックな関数型も定義可能'],
true),

('enum', 'enum', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'列挙型を定義',
'enumは名前付き定数のセットを定義。数値enumと文字列enumがあります。',
'enum Status {\n  Pending,    // 0\n  Approved,   // 1\n  Rejected    // 2\n}\n\nenum Color {\n  Red = "RED",\n  Green = "GREEN",\n  Blue = "BLUE"\n}\n\nconst status: Status = Status.Pending;\nconst color: Color = Color.Red;',
'定数の親分',
ARRAY['リテラル型unionで代替できる場面が多い', '数値enumはリバースマッピングされる罠', 'const enumでコードサイズ削減', 'Tree Shakingされない問題がある'],
'選択肢を定義',
ARRAY['関連する定数をグループ化できる', '数値enumはデフォルトで0から連番', '文字列enumは明示的な値が必要', 'リテラル型unionより厳密なチェックが可能'],
true),

('as-const', 'as const', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'リテラル型として推論',
'as constは値をリテラル型として推論させる。配列はreadonlyタプル、オブジェクトはreadonlyリテラルになります。',
'const colors = ["red", "green", "blue"] as const;\n// 型: readonly ["red", "green", "blue"]\n\nconst config = {\n  host: "localhost",\n  port: 3000\n} as const;\n// 型: { readonly host: "localhost"; readonly port: 3000 }\n\ntype Color = typeof colors[number]; // "red" | "green" | "blue"',
'凍結呪文',
ARRAY['リテラル型のunionを作るのに便利', 'オブジェクトをimmutableにする', 'typeofと組み合わせて型を抽出', 'enumの代替としても使える'],
'値を固定する',
ARRAY['配列やオブジェクトをリテラル型として推論', 'readonlyかつリテラル型になる', 'typeof と組み合わせて型を抽出できる', '設定オブジェクトの定義に最適'],
true),

('satisfies', 'satisfies', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'型チェックしつつ推論を保持',
'satisfiesは値が型を満たすことを検証しつつ、より具体的な型を推論させます。TypeScript 4.9で追加。',
'type Colors = Record<string, string | number[]>;\n\nconst colors = {\n  red: "#ff0000",\n  green: [0, 255, 0]\n} satisfies Colors;\n\n// 型は保持される\ncolors.red.toUpperCase();  // OK（stringと推論）\ncolors.green.map(n => n);  // OK（number[]と推論）',
'型チェックの新兵器',
ARRAY['as constと組み合わせると最強', '型注釈より推論を残せる', 'TS4.9以降でしか使えない', 'オブジェクトリテラルの型検証に最適'],
'型を満たすか確認',
ARRAY['型注釈と違い、具体的な型情報を保持', '設定オブジェクトの検証に最適', 'as constと組み合わせて使うことが多い', 'TS4.9以降の新機能'],
true),

('type-assertion', '型アサーション', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'型を上書きする',
'型アサーション（as構文）は開発者が型を明示的に指定する。コンパイラの推論を上書きするため、慎重に使う必要があります。',
'const input = document.getElementById("input") as HTMLInputElement;\ninput.value = "hello";\n\n// より危険な形\nconst data = response as unknown as User;',
'コンパイラへの反抗',
ARRAY['型安全性を破壊する可能性がある', 'DOMの型指定でよく使う', 'asを2回重ねる黒魔術は最終手段', '型ガードで対応できないか先に検討'],
'型を「これだ」と指定',
ARRAY['TypeScriptに「この型だ」と教える', 'DOM要素の型指定でよく使う', '間違った型を指定すると実行時エラーの原因に', 'unknownを経由すると何にでもアサートできる（危険）'],
true),

('readonly', 'readonly', '44444444-4444-4444-4444-444444444444', 'a0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'読み取り専用プロパティ',
'readonlyは再代入を禁止するモディファイア。プロパティ、配列、タプルに適用できます。',
'interface User {\n  readonly id: number;\n  name: string;\n}\n\nconst user: User = { id: 1, name: "田中" };\n// user.id = 2; // エラー\nuser.name = "佐藤"; // OK\n\nconst arr: readonly number[] = [1, 2, 3];\n// arr.push(4); // エラー',
'変更禁止令',
ARRAY['constとは違う、プロパティレベルの制約', '深いreadonlyはReadonly<T>で', 'ネストしたオブジェクトまでは守らない', 'as constとの使い分けを覚えろ'],
'書き換え禁止',
ARRAY['プロパティの再代入を防止', 'readonly配列で破壊的メソッドを禁止', 'イミュータブルなデータ構造に', 'Readonly<T>で全プロパティをreadonly化'],
true);

-- =====================
-- ジェネリクス (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('generics-basic', 'ジェネリクス基礎', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'型をパラメータ化する',
'ジェネリクスは型をパラメータとして受け取る機能。同じロジックを異なる型で再利用できます。',
'function identity<T>(arg: T): T {\n  return arg;\n}\n\nconst num = identity<number>(42);     // number\nconst str = identity("hello");         // string（推論）\n\ninterface Box<T> {\n  value: T;\n}\nconst box: Box<string> = { value: "hello" };',
'型の変数',
ARRAY['<T>のTは慣習、何でもいい', '推論できる場合は省略可能', '複数の型パラメータ<T, U>も可', 'Javaのジェネリクスより柔軟'],
'型を変数のように扱う',
ARRAY['<T>で型パラメータを定義', '関数、インターフェース、クラスで使える', '呼び出し時に具体的な型を指定（または推論）', 're-usableなコードを型安全に書ける'],
true),

('generic-constraint', '制約付きジェネリクス', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'型パラメータに制約を設ける',
'extendsキーワードで型パラメータに制約を設けられます。特定のプロパティや型を持つことを保証できます。',
'interface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(arg: T): void {\n  console.log(arg.length);\n}\n\nlogLength("hello");      // OK\nlogLength([1, 2, 3]);    // OK\n// logLength(123);       // エラー（lengthがない）',
'制限付きジェネリクス',
ARRAY['extends で「〜を含む型」に制限', 'keyofと組み合わせてプロパティ名を制限', '制約が複雑になると読みにくい', 'Omit<T, K>等のユーティリティ型も制約を使ってる'],
'型の条件を指定',
ARRAY['extends で型パラメータに条件を設ける', '特定のプロパティを持つ型に限定できる', 'プリミティブ型を除外することも可能', 'より安全で意図が明確なジェネリクスに'],
true),

('keyof', 'keyof', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'オブジェクトのキーをunion型に',
'keyofはオブジェクト型のキー名をunion型として取得します。',
'interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype UserKey = keyof User; // "id" | "name" | "email"\n\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user: User = { id: 1, name: "田中", email: "a@b.com" };\nconst name = getProperty(user, "name"); // string型',
'キー抽出マシン',
ARRAY['インデックス型と組み合わせてプロパティアクセスを型安全に', 'Mapped Typesの基礎', 'typeof と組み合わせると強力', 'オブジェクトの全キーを網羅したいときに'],
'オブジェクトのキーを型に',
ARRAY['オブジェクト型からキー名のunion型を作る', 'プロパティアクセスを型安全にする定番パターン', 'typeof と組み合わせて実際の値からキーを取得', 'Mapped Types の基礎になる概念'],
true),

('typeof-type', 'typeof（型コンテキスト）', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'値から型を取得',
'型コンテキストでのtypeofは値の型を取得します。実行時のtypeofとは別物です。',
'const user = {\n  name: "田中",\n  age: 30\n};\n\ntype User = typeof user; // { name: string; age: number }\n\nconst colors = ["red", "green", "blue"] as const;\ntype Color = typeof colors[number]; // "red" | "green" | "blue"\n\nfunction add(a: number, b: number) { return a + b; }\ntype AddFn = typeof add; // (a: number, b: number) => number',
'型の逆引き',
ARRAY['実際の値から型を生成できる', 'as const と組み合わせてリテラル型を取得', '関数の型を取得するのにも使える', 'ReturnType<typeof fn>が定番パターン'],
'値の型を抽出',
ARRAY['実際の値から型を生成できる', '既存のオブジェクトから型を作りたいときに', 'as const と組み合わせるとリテラル型に', '関数の型取得にも使える'],
true),

('indexed-access', 'インデックスアクセス型', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'プロパティの型を取得',
'T[K]形式でオブジェクト型の特定プロパティの型を取得します。',
'interface User {\n  id: number;\n  name: string;\n  address: {\n    city: string;\n    zip: string;\n  };\n}\n\ntype UserId = User["id"];           // number\ntype UserName = User["name"];       // string\ntype City = User["address"]["city"]; // string\ntype IdOrName = User["id" | "name"]; // number | string',
'型の部分抽出',
ARRAY['ネストしたプロパティの型も取得可能', 'union型のキーを渡すとunion型が返る', '配列のT[number]で要素の型を取得', 'keyofと組み合わせると強力'],
'プロパティの型を取り出す',
ARRAY['T["key"]で特定プロパティの型を取得', 'ネストしたプロパティも辿れる', 'T[number]で配列要素の型を取得', 'keyofと組み合わせて汎用関数を作れる'],
true),

('partial', 'Partial<T>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'全プロパティをオプショナルに',
'Partialはすべてのプロパティをオプショナルにするユーティリティ型。更新処理で部分的なデータを渡す場合に便利です。',
'interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction updateUser(id: number, updates: Partial<User>) {\n  // updatesは{ id?: number; name?: string; email?: string }\n}\n\nupdateUser(1, { name: "新しい名前" }); // OK',
'全部任意にする魔法',
ARRAY['更新系APIの引数型で頻出', 'Required<T>は逆に全部必須にする', 'DeepPartialは自分で作る必要がある', 'Mapped Typesで実装されている'],
'全プロパティを省略可能に',
ARRAY['すべてのプロパティに?がつく', '更新処理で部分的なデータを受け取るのに最適', 'Required<T>は逆に全プロパティを必須に', '内部的にはMapped Typesで実装'],
true),

('required', 'Required<T>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'全プロパティを必須に',
'Requiredはすべてのオプショナルプロパティを必須にするユーティリティ型。',
'interface Config {\n  host?: string;\n  port?: number;\n  ssl?: boolean;\n}\n\ntype RequiredConfig = Required<Config>;\n// { host: string; port: number; ssl: boolean }\n\nfunction initServer(config: RequiredConfig) {\n  // すべてのプロパティが必須\n}',
'オプショナル撲滅',
ARRAY['Partialの逆', 'デフォルト値を適用した後の型に', '-?で各プロパティから?を削除している', 'オブジェクトの完全性を保証したいときに'],
'全プロパティを必須に',
ARRAY['オプショナルプロパティを強制的に必須に', 'Partial<T>の逆の効果', 'デフォルト値適用後の型として使える', '設定オブジェクトの完全な型を定義'],
true),

('pick', 'Pick<T, K>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'特定のプロパティだけ抽出',
'Pickは指定したプロパティだけを持つ型を作成します。',
'interface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\ntype PublicUser = Pick<User, "id" | "name" | "email">;\n// { id: number; name: string; email: string }',
'いいとこ取り',
ARRAY['APIレスポンスで不要なフィールドを除外', 'Omitは逆に除外したいプロパティを指定', '第2引数はkeyof Tのサブセット', 'DTOの定義でよく使う'],
'必要なプロパティだけ選ぶ',
ARRAY['指定したキーのプロパティだけを持つ型を作る', 'APIレスポンスの公開部分を定義するのに便利', 'Omit<T, K>は逆に除外するプロパティを指定', '元の型から必要な部分だけ抜き出せる'],
true),

('omit', 'Omit<T, K>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'特定のプロパティを除外',
'Omitは指定したプロパティを除外した型を作成します。Pickの逆の操作です。',
'interface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\ntype SafeUser = Omit<User, "password">;\n// { id: number; name: string; email: string }\n\ntype CreateUser = Omit<User, "id">;\n// idは自動生成される場合',
'要らないものを消す',
ARRAY['passwordを除外したユーザー型は定番', '存在しないキーを指定してもエラーにならない', 'Pick & Omitで型を再構築', 'intersectionで新しいプロパティを追加'],
'除外して新しい型を作る',
ARRAY['指定したキーを除いた型を作る', 'パスワードを除外した公開用型など', 'id抜きの作成用型を作るのにも便利', '& で追加のプロパティを足せる'],
true),

('record', 'Record<K, V>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'キーと値の型を指定した辞書型',
'Recordはキーの型と値の型を指定してオブジェクト型を作ります。',
'type Status = "pending" | "approved" | "rejected";\ntype StatusInfo = Record<Status, { label: string; color: string }>;\n\nconst statusMap: StatusInfo = {\n  pending: { label: "保留中", color: "yellow" },\n  approved: { label: "承認済", color: "green" },\n  rejected: { label: "却下", color: "red" }\n};\n\n// 汎用的な辞書型\ntype StringDict = Record<string, string>;',
'辞書型ビルダー',
ARRAY['{ [key: string]: T }より型安全', 'リテラル型unionをキーにすると網羅性チェック', 'Mapとは違う、プレーンオブジェクト用', '設定やマッピングの定義に最適'],
'キーと値の型を定義',
ARRAY['Record<K, V>でキーの型と値の型を指定', 'リテラル型unionをキーにすると全キーが必須に', 'マッピングオブジェクトの型定義に最適', '{ [key: string]: T }より意図が明確'],
true),

('exclude', 'Exclude<T, U>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'union型から特定の型を除外',
'Excludeはunion型Tから型Uを除外した型を作ります。',
'type Status = "pending" | "approved" | "rejected" | "cancelled";\ntype ActiveStatus = Exclude<Status, "cancelled">;\n// "pending" | "approved" | "rejected"\n\ntype NonNullable<T> = Exclude<T, null | undefined>;',
'union型の引き算',
ARRAY['Extract<T, U>は逆に残したい型を指定', 'Conditional Typesで実装されている', 'NonNullable<T>はExcludeで実装', 'Omitとの違いを理解しろ'],
'union型から型を除外',
ARRAY['union型から特定の型を取り除く', 'Extract<T, U>は逆に抽出する', 'NonNullable<T>の内部実装に使われている', 'Omitはオブジェクトのキー、Excludeはunion型'],
true),

('extract', 'Extract<T, U>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'union型から特定の型を抽出',
'Extractはunion型TからUに代入可能な型だけを抽出します。',
'type Status = "pending" | "approved" | "rejected" | 100 | 200;\ntype StringStatus = Extract<Status, string>;\n// "pending" | "approved" | "rejected"\n\ntype NumericStatus = Extract<Status, number>;\n// 100 | 200',
'union型のフィルター',
ARRAY['Exclude<T, U>の逆', '共通部分を抽出するイメージ', '型レベルのフィルタリング', '関数型のunionから特定シグネチャを抽出'],
'条件に合う型だけ抽出',
ARRAY['union型から条件に合う型だけを残す', 'Exclude<T, U>の逆の操作', '型レベルのfilterのような動作', '複合union型の整理に便利'],
true),

('return-type', 'ReturnType<T>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'関数の戻り値型を取得',
'ReturnTypeは関数型の戻り値の型を取得します。',
'function getUser() {\n  return { id: 1, name: "田中" };\n}\n\ntype User = ReturnType<typeof getUser>;\n// { id: number; name: string }\n\n// 非同期関数の場合\nasync function fetchUser() {\n  return { id: 1, name: "田中" };\n}\ntype FetchedUser = Awaited<ReturnType<typeof fetchUser>>;',
'戻り値型の逆引き',
ARRAY['typeof fnと組み合わせて使う', 'Promise<T>のTを取るにはAwaited<T>も必要', 'Parameters<T>は引数の型を取得', '既存関数から型を導出するテクニック'],
'関数の戻り値型を取り出す',
ARRAY['関数型から戻り値の型を取得', 'typeof functionと組み合わせて使う', 'Promise<T>はAwaited<T>でアンラップ', 'Parameters<T>で引数の型も取得可能'],
true),

('parameters', 'Parameters<T>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'関数の引数型をタプルで取得',
'Parametersは関数型の引数の型をタプルとして取得します。',
'function greet(name: string, age: number) {\n  console.log(`${name} (${age})`);\n}\n\ntype GreetParams = Parameters<typeof greet>;\n// [name: string, age: number]\n\nfunction call(...args: GreetParams) {\n  greet(...args);\n}',
'引数型の抽出',
ARRAY['ReturnType<T>と対になるユーティリティ型', 'ラッパー関数の引数型に使える', 'タプル型で返ってくる', 'Parameters<T>[0]で第1引数の型を取得'],
'関数の引数型を取り出す',
ARRAY['関数型から引数の型をタプルで取得', 'ラッパー関数の実装に便利', 'Parameters<T>[0]で第1引数の型', 'ReturnType<T>と組み合わせて関数型を再利用'],
true),

('awaited', 'Awaited<T>', '44444444-4444-4444-4444-444444444444', 'a0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'Promiseをアンラップ',
'AwaitedはPromise<T>からTを取り出します。ネストしたPromiseも再帰的にアンラップします。',
'type A = Awaited<Promise<string>>;        // string\ntype B = Awaited<Promise<Promise<number>>>; // number\ntype C = Awaited<boolean | Promise<number>>; // boolean | number\n\nasync function fetchData() {\n  return { id: 1 };\n}\ntype Data = Awaited<ReturnType<typeof fetchData>>; // { id: number }',
'Promise剥がし',
ARRAY['TS4.5で追加', 'ReturnType<typeof asyncFn>と組み合わせる定番', 'ネストしたPromiseも一発', 'async関数の戻り値型を取得するのに必須'],
'Promiseの中身を取り出す',
ARRAY['Promise<T>からTを取得', 'ネストしたPromiseも再帰的にアンラップ', 'async関数の実際の戻り値型を取得するのに便利', 'ReturnType<typeof asyncFn>と組み合わせる'],
true);

-- =====================
-- 型ガード (10件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('typeof-guard', 'typeof型ガード', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'beginner',
'プリミティブ型を絞り込む',
'typeofを使った条件分岐で型を絞り込みます。string, number, boolean, symbol, bigint, undefined, functionに対応。',
'function process(value: string | number) {\n  if (typeof value === "string") {\n    // ここではstring型\n    return value.toUpperCase();\n  } else {\n    // ここではnumber型\n    return value.toFixed(2);\n  }\n}',
'プリミティブ判定',
ARRAY['nullはtypeof "object"になる罠', 'arrayもtypeof "object"', 'プリミティブ型にしか使えない', 'TypeScriptが自動で型を絞り込んでくれる'],
'型を調べて絞り込む',
ARRAY['typeofでプリミティブ型を判定', '条件分岐後は型が自動で絞り込まれる', 'nullやarrayはobjectになるので注意', 'string, number, boolean等で使える'],
true),

('instanceof-guard', 'instanceof型ガード', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'beginner',
'クラスインスタンスを絞り込む',
'instanceofを使ってクラスのインスタンスかどうかを判定し、型を絞り込みます。',
'class Dog {\n  bark() { console.log("Woof!"); }\n}\nclass Cat {\n  meow() { console.log("Meow!"); }\n}\n\nfunction speak(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();  // Dog型に絞り込み\n  } else {\n    animal.meow();  // Cat型に絞り込み\n  }\n}',
'クラス判定',
ARRAY['クラスベースの型ガードはこれ一択', 'interfaceには使えない', 'プロトタイプチェーンで判定している', 'エラーハンドリングでよく使う'],
'クラスインスタンスを判定',
ARRAY['instanceofでクラスのインスタンスか判定', '継承関係も考慮される', 'Error instanceof Errorなどエラー処理で頻出', 'interfaceには使えないので注意'],
true),

('in-guard', 'in演算子型ガード', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'プロパティの存在で絞り込む',
'in演算子でプロパティの存在を確認し、型を絞り込みます。interfaceの判別に便利。',
'interface Fish { swim(): void; }\ninterface Bird { fly(): void; }\n\nfunction move(animal: Fish | Bird) {\n  if ("swim" in animal) {\n    animal.swim();  // Fish型に絞り込み\n  } else {\n    animal.fly();   // Bird型に絞り込み\n  }\n}',
'プロパティ存在チェック',
ARRAY['interfaceの型ガードに使える', '判別用プロパティを持たせるのがコツ', 'hasOwnPropertyより簡潔', 'プロトタイプチェーンも探索する'],
'プロパティの有無で判定',
ARRAY['特定のプロパティがあるか確認して型を絞る', 'interfaceの判別に便利', '"key" in objectの形式', 'instanceofが使えない場面で活躍'],
true),

('discriminated-union', '判別可能なunion型', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'共通プロパティで型を判別',
'リテラル型の共通プロパティ（判別子）を持つunion型。switch文で網羅的に処理できます。',
'type Success = { type: "success"; data: string };\ntype Error = { type: "error"; message: string };\ntype Loading = { type: "loading" };\n\ntype State = Success | Error | Loading;\n\nfunction handle(state: State) {\n  switch (state.type) {\n    case "success":\n      return state.data;    // Success型\n    case "error":\n      return state.message; // Error型\n    case "loading":\n      return "読込中";      // Loading型\n  }\n}',
'型のタグ付け',
ARRAY['Reduxのアクション型の定番パターン', 'typeやkindをタグとして使う', 'switch文で網羅性チェックができる', 'タグ付きunion型とも呼ばれる'],
'共通のタグで型を分ける',
ARRAY['リテラル型のプロパティで型を判別', 'switch文で網羅的に処理できる', 'Reduxアクション等の状態管理に最適', '判別子を追加すれば新しい型も安全に追加'],
true),

('type-predicate', '型述語（is）', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'カスタム型ガード関数を定義',
'戻り値型に「arg is Type」と書くと、trueを返したときにその型に絞り込まれます。',
'interface Fish { swim(): void; }\ninterface Bird { fly(): void; }\n\nfunction isFish(animal: Fish | Bird): animal is Fish {\n  return "swim" in animal;\n}\n\nfunction move(animal: Fish | Bird) {\n  if (isFish(animal)) {\n    animal.swim();  // Fish型に絞り込み\n  } else {\n    animal.fly();   // Bird型に絞り込み\n  }\n}',
'型ガード関数の作り方',
ARRAY['複雑な判定ロジックを関数に切り出せる', 'booleanを返すだけではダメ', '実装が間違っていても型エラーにならない罠', 'assertsと使い分ける'],
'自作の型ガード関数',
ARRAY['戻り値型を「arg is Type」で宣言', 'trueを返すとその型に絞り込まれる', '複雑な型判定ロジックを関数化できる', 'TypeScriptが自動で型を追跡してくれる'],
true),

('assertion-function', 'アサーション関数（asserts）', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'advanced',
'条件を満たさなければ例外を投げる型ガード',
'asserts構文で「この関数が正常に終了したら型が保証される」ことを表現します。',
'function assertIsString(value: unknown): asserts value is string {\n  if (typeof value !== "string") {\n    throw new Error("Not a string!");\n  }\n}\n\nfunction process(value: unknown) {\n  assertIsString(value);\n  // ここではstring型として扱える\n  console.log(value.toUpperCase());\n}\n\n// 条件だけをアサートする場合\nfunction assert(condition: unknown): asserts condition {\n  if (!condition) throw new Error("Assertion failed");\n}',
'例外型ガード',
ARRAY['Node.jsのassertモジュールの型付け版', 'throwしないと型が絞り込まれない', 'テストコードで威力を発揮', 'is型述語との使い分けを覚えろ'],
'例外で型を保証',
ARRAY['関数が正常終了=型が保証される', '条件を満たさなければ例外を投げる', 'テストのassertや前提条件チェックに', 'is型述語は値を返す、assertsは例外を投げる'],
true),

('narrowing', '型の絞り込み（Narrowing）', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'条件分岐で型を特定する',
'TypeScriptは制御フローを解析して、条件分岐後の型を自動的に絞り込みます。',
'function example(value: string | number | null) {\n  // 型: string | number | null\n  \n  if (value === null) {\n    return; // 早期リターン\n  }\n  // 型: string | number\n  \n  if (typeof value === "string") {\n    // 型: string\n    console.log(value.toUpperCase());\n  } else {\n    // 型: number\n    console.log(value.toFixed(2));\n  }\n}',
'型の自動推理',
ARRAY['TypeScriptの制御フロー解析は賢い', '早期リターンでnullを除外するパターン', '&&や||でも絞り込みが働く', '型ガードを書く前にnarrowingを試せ'],
'条件分岐で型が変わる',
ARRAY['if文やswitch文で型が自動的に絞り込まれる', '早期リターンでnull/undefinedを除外', 'TypeScriptが制御フローを解析している', '明示的な型ガードが不要な場合も多い'],
true),

('nullish-check', 'nullチェック', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'beginner',
'null/undefinedを除外',
'strictNullChecks下でnull/undefinedを安全に扱う方法。if文、??、?.などを使います。',
'function greet(name: string | null | undefined) {\n  // if文でチェック\n  if (name != null) {\n    console.log(name.toUpperCase());\n  }\n  \n  // ?? でデフォルト値\n  const displayName = name ?? "Guest";\n  \n  // ?. でオプショナルチェーン\n  console.log(name?.toUpperCase());\n}',
'null安全の基本',
ARRAY['!= null でnullとundefined両方チェック', '??はnullとundefinedだけ、||は0や空文字も', '!（非nullアサーション）は最終手段', 'strictNullChecksは絶対にtrueにしろ'],
'null/undefinedを安全に処理',
ARRAY['!= null でnullとundefined両方を除外', '??演算子でデフォルト値を設定', '?.演算子で安全にプロパティアクセス', 'strictNullChecksで安全性を保証'],
true),

('non-null-assertion', '非nullアサーション（!）', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'null/undefinedではないと宣言',
'後置の!演算子で「この値はnull/undefinedではない」とTypeScriptに伝えます。',
'const input = document.getElementById("input")!;\n// nullの可能性を無視してHTMLElement型に\n\ninterface User {\n  name?: string;\n}\nconst user: User = { name: "田中" };\nconsole.log(user.name!.toUpperCase());\n// nameがundefinedの可能性を無視',
'強制的なnull無視',
ARRAY['型アサーションの一種で危険', '実行時にnullならエラーになる', 'DOM操作でよく見るが代替手段を検討しろ', '本当にnullにならないと確信できるときだけ使え'],
'「絶対にnullじゃない」宣言',
ARRAY['null/undefinedではないと断言する', '実行時のnullチェックは行われない', '使いすぎると型安全性が損なわれる', 'DOM要素の取得など確実な場面で使用'],
true),

('type-coercion', '型強制変換', '44444444-4444-4444-4444-444444444444', 'a0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'異なる型に変換する',
'TypeScriptでの型変換はJavaScriptの組み込み関数を使います。型アサーションとは異なり、実際に値が変換されます。',
'// 文字列 → 数値\nconst str = "42";\nconst num1 = Number(str);     // 42\nconst num2 = parseInt(str);   // 42\nconst num3 = +str;            // 42\n\n// 数値 → 文字列\nconst num = 42;\nconst str1 = String(num);     // "42"\nconst str2 = num.toString();  // "42"\nconst str3 = `${num}`;        // "42"\n\n// 真偽値変換\nconst bool = Boolean("hello"); // true\nconst bool2 = !!"hello";       // true',
'実際の型変換',
ARRAY['型アサーション(as)は見かけだけ、これは実際に変換', 'Number("abc")はNaNになる', '暗黙の型変換に頼るな、明示的に変換しろ', 'parseIntは第2引数(基数)を必ず指定'],
'値を実際に変換する',
ARRAY['Number(), String(), Boolean()で明示的に変換', '型アサーション(as)とは違い実際に値が変わる', 'parseIntは基数を必ず指定（10を推奨）', '暗黙の変換より明示的な変換を推奨'],
true);

-- =====================
-- ユーティリティ型 (10件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('readonly-utility', 'Readonly<T>', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'全プロパティをreadonly化',
'Readonlyはすべてのプロパティにreadonlyを付与する型。浅いreadonlyなので注意。',
'interface User {\n  id: number;\n  name: string;\n}\n\nconst user: Readonly<User> = { id: 1, name: "田中" };\n// user.id = 2; // エラー\n\n// ネストしたオブジェクトは変更可能\ninterface Deep {\n  nested: { value: number };\n}\nconst deep: Readonly<Deep> = { nested: { value: 1 } };\ndeep.nested.value = 2; // OK（浅いreadonly）',
'浅い凍結',
ARRAY['ネストしたオブジェクトは保護されない', 'DeepReadonlyは自分で定義するか、ライブラリを使う', 'as constの方が便利な場面も', 'Object.freeze()の型版'],
'全プロパティを読み取り専用に',
ARRAY['すべてのプロパティにreadonlyが付く', '浅いreadonlyなのでネストには効かない', 'イミュータブルなデータを扱う際に', 'Requiredと組み合わせることも可能'],
true),

('nonnullable', 'NonNullable<T>', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'null/undefinedを除外',
'NonNullableはunion型からnullとundefinedを除外します。',
'type MaybeString = string | null | undefined;\ntype DefiniteString = NonNullable<MaybeString>;\n// string\n\nfunction process<T>(value: T): NonNullable<T> {\n  if (value == null) {\n    throw new Error("Value is null or undefined");\n  }\n  return value as NonNullable<T>;\n}',
'nullを排除',
ARRAY['Exclude<T, null | undefined>と同じ', '関数の戻り値型でよく使う', 'strictNullChecksがtrueでないと意味がない', '型レベルでnullabilityを除去'],
'null/undefinedを取り除く',
ARRAY['union型からnullとundefinedを除外', '型の「nullable」を解除する', 'Exclude<T, null | undefined>のエイリアス', '関数の戻り値型の整理に便利'],
true),

('constructor-parameters', 'ConstructorParameters<T>', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'コンストラクタの引数型を取得',
'ConstructorParametersはクラスのコンストラクタ引数の型をタプルで取得します。',
'class User {\n  constructor(public name: string, public age: number) {}\n}\n\ntype UserParams = ConstructorParameters<typeof User>;\n// [name: string, age: number]\n\nfunction createUser(...args: ConstructorParameters<typeof User>) {\n  return new User(...args);\n}',
'コンストラクタ引数の抽出',
ARRAY['typeof Classを渡す必要がある', 'ファクトリー関数の型付けに便利', 'Parametersのクラス版', 'abstractクラスには使えない'],
'コンストラクタの引数型を取得',
ARRAY['クラスのコンストラクタ引数をタプル型で取得', 'typeof Classを渡して使う', 'ファクトリー関数の実装に便利', 'Parametersのコンストラクタ版'],
true),

('instance-type', 'InstanceType<T>', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'クラスのインスタンス型を取得',
'InstanceTypeはコンストラクタ関数型からインスタンスの型を取得します。',
'class User {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\ntype UserInstance = InstanceType<typeof User>;\n// User\n\nfunction create<T extends new (...args: any[]) => any>(\n  ctor: T,\n  ...args: ConstructorParameters<T>\n): InstanceType<T> {\n  return new ctor(...args);\n}',
'インスタンス型の取得',
ARRAY['typeof Classを渡す', 'ジェネリックなファクトリーで活躍', '普通はクラス名をそのまま使えばいい', '動的にクラスを受け取る場面で必要'],
'クラスのインスタンス型を取得',
ARRAY['コンストラクタ型からインスタンス型を抽出', 'typeof Classを渡して使う', 'ジェネリックなファクトリー関数で活躍', '通常はクラス名をそのまま型として使えばOK'],
true),

('this-type', 'ThisType<T>', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'thisの型を指定',
'ThisTypeはオブジェクトリテラル内でthisの型を指定するマーカー型。Vueのオプション型APIで有名。',
'interface Methods {\n  greet(): string;\n}\n\ninterface Data {\n  name: string;\n}\n\ntype ObjectWithThis = Methods & ThisType<Data & Methods>;\n\nconst obj: ObjectWithThis = {\n  greet() {\n    return `Hello, ${this.name}`; // thisはData & Methods型\n  }\n};\n\n// noImplicitThisが必要',
'this型の指定',
ARRAY['Vue2のオプションAPIで使われている', 'noImplicitThis: trueが必要', 'ミックスインパターンで活躍', '普通のコードではほぼ使わない'],
'thisの型を明示的に指定',
ARRAY['オブジェクトリテラル内のthisの型を定義', 'Vue.jsのオプションAPIで有名', 'noImplicitThis: trueと組み合わせる', 'ミックスインパターンの型付けに'],
true),

('string-manipulation', '文字列操作型', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'テンプレートリテラル型の操作',
'Uppercase, Lowercase, Capitalize, Uncapitalizeは文字列リテラル型を変換します。',
'type Upper = Uppercase<"hello">;      // "HELLO"\ntype Lower = Lowercase<"HELLO">;      // "hello"\ntype Cap = Capitalize<"hello">;       // "Hello"\ntype Uncap = Uncapitalize<"Hello">;   // "hello"\n\n// イベントハンドラ名の生成\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype ClickHandler = EventName<"click">; // "onClick"',
'文字列型の変換',
ARRAY['テンプレートリテラル型と組み合わせると強力', 'APIのキー名変換に使える', '実行時には何も起きない、型レベルだけ', 'kebab-caseへの変換は自分で作る必要あり'],
'文字列リテラル型を変換',
ARRAY['Uppercase/Lowercaseで大文字小文字変換', 'Capitalize/Uncapitalizeで先頭文字を変換', 'テンプレートリテラル型と組み合わせる', 'イベントハンドラ名の生成などに活用'],
true),

('template-literal', 'テンプレートリテラル型', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'文字列パターンを型で表現',
'バッククォートで文字列のパターンを型として表現。union型と組み合わせると強力です。',
'type Color = "red" | "blue" | "green";\ntype Size = "small" | "medium" | "large";\n\ntype ColorSize = `${Color}-${Size}`;\n// "red-small" | "red-medium" | "red-large" | "blue-small" | ...\n\ntype HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";\ntype Endpoint = `/api/${string}`;\n\nfunction fetch(method: HTTPMethod, url: Endpoint) {\n  // ...\n}',
'文字列パターン型',
ARRAY['unionの直積が自動生成される', 'CSSクラス名やAPIエンドポイントの型定義に', '組み合わせ爆発に注意', 'TypeScript 4.1で追加'],
'文字列のパターンを型に',
ARRAY['バッククォートで文字列パターンを定義', 'union型と組み合わせて全パターンを生成', 'CSSクラス名やURLパターンの型付けに', '型安全な文字列操作を実現'],
true),

('mapped-types', 'Mapped Types', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'既存の型を変換して新しい型を作る',
'{ [K in keyof T]: ... }の形式で、既存の型のプロパティを変換した新しい型を作ります。',
'// Partialの実装\ntype MyPartial<T> = {\n  [K in keyof T]?: T[K];\n};\n\n// Readonlyの実装\ntype MyReadonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n\n// 値の型を変換\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ninterface User { name: string; age: number; }\ntype UserGetters = Getters<User>;\n// { getName: () => string; getAge: () => number; }',
'型の変換器',
ARRAY['Partial, Required, Readonlyの実装原理', 'as句でキー名を変換できる（TS4.1+）', '+/-でモディファイアを追加/削除', '型プログラミングの基礎'],
'型を一括変換',
ARRAY['[K in keyof T]で全プロパティをイテレート', '?やreadonlyを一括で付与/削除', 'asでキー名の変換も可能', 'Partial<T>等のユーティリティ型の実装原理'],
true),

('conditional-types', 'Conditional Types', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'条件分岐で型を決定',
'T extends U ? X : Y の形式で、条件に基づいて型を選択します。',
'type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<"hello">;  // true\ntype B = IsString<123>;       // false\n\n// Extractの実装\ntype MyExtract<T, U> = T extends U ? T : never;\n\n// 配列の要素型を取得\ntype ElementType<T> = T extends (infer E)[] ? E : never;\ntype Elem = ElementType<string[]>;  // string',
'型の三項演算子',
ARRAY['union型に適用すると分配される', 'inferで型を抽出できる', 'neverは除外される性質を活用', 'Extract, Excludeの実装原理'],
'条件によって型を選ぶ',
ARRAY['T extends U ? X : Yで条件分岐', '型レベルの三項演算子', 'inferキーワードで型を抽出可能', 'union型に分配される性質を持つ'],
true),

('infer', 'infer', '44444444-4444-4444-4444-444444444444', 'a0444444-4444-4444-4444-444444444444', 'syntax', 'advanced',
'条件型の中で型を推論',
'inferキーワードを使って、条件型の中で型変数を宣言し、パターンマッチで型を抽出します。',
'// 配列の要素型を取得\ntype ElementOf<T> = T extends (infer E)[] ? E : never;\ntype Elem = ElementOf<string[]>;  // string\n\n// 関数の戻り値型を取得（ReturnTypeの実装）\ntype MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\n// Promiseの中身を取得\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\ntype Result = UnwrapPromise<Promise<string>>;  // string\n\n// タプルの最初の要素\ntype Head<T> = T extends [infer H, ...any[]] ? H : never;',
'型のパターンマッチ',
ARRAY['Conditional Typesの中でのみ使える', 'extendsの右側でパターンを書く', 'ReturnType, Parameters等の実装に必須', '再帰型と組み合わせると黒魔術'],
'型をパターンマッチで抽出',
ARRAY['条件型の中で型変数を宣言', 'パターンにマッチした部分の型を取り出す', 'ReturnType<T>等の実装に使われている', '配列、関数、Promise等の「中身」を取得'],
true);

-- =====================
-- 高度な型 (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('declare', 'declare', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'型情報だけを宣言',
'declareは実装なしで型情報だけを宣言。グローバル変数や外部ライブラリの型定義に使います。',
'// グローバル変数の宣言\ndeclare const API_URL: string;\n\n// 関数の宣言\ndeclare function greet(name: string): void;\n\n// モジュールの宣言（.d.tsファイル内）\ndeclare module "some-library" {\n  export function doSomething(): void;\n}\n\n// グローバル拡張\ndeclare global {\n  interface Window {\n    myCustomProp: string;\n  }\n}',
'型だけの宣言',
ARRAY['.d.tsファイルで使うのが基本', 'JavaScriptには何も出力されない', 'グローバル汚染に注意', 'DefinitelyTypedの型定義はこれで書かれている'],
'型情報だけを定義',
ARRAY['実装なしで型だけを宣言', '外部ライブラリの型定義に', '.d.tsファイルで使用', 'コンパイル後のJSには残らない'],
true),

('namespace', 'namespace', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'名前空間を定義',
'namespaceは関連する型や値をグループ化。モジュールシステムの前身だが、型のグループ化にはまだ使われます。',
'namespace Validation {\n  export interface StringValidator {\n    isValid(s: string): boolean;\n  }\n  \n  export class EmailValidator implements StringValidator {\n    isValid(s: string) {\n      return s.includes("@");\n    }\n  }\n}\n\nconst validator: Validation.StringValidator = new Validation.EmailValidator();',
'レガシーな名前空間',
ARRAY['ESモジュールが主流の今、出番は減った', '型のグループ化には今でも使える', 'enum内のnamespaceは黒魔術', 'declare namespaceは外部ライブラリの型定義で見る'],
'関連する型をまとめる',
ARRAY['関連する型や値を1つの名前空間に', 'ESモジュールが主流だが型のグループ化には有用', 'declare namespaceは外部ライブラリの型で見かける', 'exportしないとnamespace外から見えない'],
true),

('ambient-module', 'アンビエントモジュール', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'モジュールの型を宣言',
'declare moduleで外部モジュールの型を宣言。型定義のないライブラリを使う際に必要です。',
'// 型定義のないライブラリ\ndeclare module "untyped-lib" {\n  export function doSomething(): void;\n  export const version: string;\n}\n\n// CSSモジュール\ndeclare module "*.css" {\n  const styles: { [className: string]: string };\n  export default styles;\n}\n\n// 画像ファイル\ndeclare module "*.png" {\n  const src: string;\n  export default src;\n}',
'型なしライブラリの救済',
ARRAY['DefinitelyTypedに型がないときの応急処置', 'ワイルドカードでファイル拡張子に対応', 'global.d.tsに書くのが慣例', '後で@types/xxxがあれば削除'],
'外部モジュールに型をつける',
ARRAY['型定義のないライブラリに型を追加', 'CSSや画像ファイルのimportにも対応', 'global.d.tsに書くのが一般的', '@types/xxxがあればそちらを優先'],
true),

('declaration-merging', '宣言マージ', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'同名の宣言を結合',
'TypeScriptは同名のinterface、namespace、classを自動的にマージします。',
'// interfaceのマージ\ninterface User {\n  name: string;\n}\ninterface User {\n  age: number;\n}\n// User = { name: string; age: number }\n\n// namespaceとclassのマージ\nclass Album {\n  label: Album.Label;\n}\nnamespace Album {\n  export type Label = string;\n}\n\n// グローバル型の拡張\ndeclare global {\n  interface Array<T> {\n    customMethod(): T[];\n  }\n}',
'宣言の合体',
ARRAY['interfaceは自動マージ、typeはエラー', 'ライブラリの型を拡張する定番テクニック', 'Expressのreq拡張でよく見る', 'マージ順序で同名プロパティの型が変わる罠'],
'同名の宣言が結合される',
ARRAY['interfaceは同名で宣言すると自動マージ', 'ライブラリの型を拡張するのに便利', 'classとnamespaceもマージ可能', 'typeはマージ不可なので注意'],
true),

('type-vs-interface', 'type vs interface', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'beginner',
'どちらを使うべきか',
'typeとinterfaceは似ているが違いがある。チームで統一することが重要。',
'// interfaceでしかできないこと\n// 1. 宣言マージ\ninterface User { name: string; }\ninterface User { age: number; } // マージ\n\n// 2. extendsでの継承がシンプル\ninterface Admin extends User { role: string; }\n\n// typeでしかできないこと\n// 1. プリミティブ型のalias\ntype ID = string;\n\n// 2. union/intersection/タプル\ntype Result = Success | Error;\ntype Point = [number, number];\n\n// 3. Mapped Types\ntype Readonly<T> = { readonly [K in keyof T]: T[K] };',
'永遠の論争',
ARRAY['「オブジェクトはinterface、それ以外はtype」派が多い', 'Reactコンポーネントのpropsはinterface派とtype派で分かれる', 'ライブラリ作者はinterfaceを好む傾向', '結局チームで統一することが大事'],
'使い分けのガイドライン',
ARRAY['オブジェクトの形を定義 → どちらでもOK', 'union/タプル/プリミティブalias → type', '宣言マージしたい → interface', 'チームで統一することが最重要'],
true),

('structural-typing', '構造的型付け', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'型の互換性は構造で決まる',
'TypeScriptは名前ではなく構造で型の互換性を判断（ダックタイピング）。',
'interface Point {\n  x: number;\n  y: number;\n}\n\ninterface Coordinate {\n  x: number;\n  y: number;\n}\n\nconst point: Point = { x: 1, y: 2 };\nconst coord: Coordinate = point; // OK（構造が同じ）\n\n// 余分なプロパティがあっても互換\nconst point3D = { x: 1, y: 2, z: 3 };\nconst p: Point = point3D; // OK',
'ダックタイピング',
ARRAY['Javaの名前的型付けとは違う', '「アヒルのように歩けばアヒル」', '余分なプロパティがあっても通る', 'ブランド型で厳密にしたいときもある'],
'構造が同じなら互換',
ARRAY['型名ではなく構造で互換性を判断', '同じ形なら別々に定義した型でも代入可能', '余分なプロパティがあっても互換', 'JavaやC#の名前的型付けとは異なる'],
true),

('branded-type', 'ブランド型', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'構造的型付けを回避する',
'同じ構造でも区別したい場合、ブランド（タグ）を付けて名前的型付けを模倣します。',
'type UserId = string & { readonly brand: unique symbol };\ntype PostId = string & { readonly brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createPostId(id: string): PostId {\n  return id as PostId;\n}\n\nfunction getUser(id: UserId) { /* ... */ }\n\nconst userId = createUserId("user-1");\nconst postId = createPostId("post-1");\n\ngetUser(userId); // OK\n// getUser(postId); // エラー！',
'見えないタグ付け',
ARRAY['同じstringでも混同を防ぐ', 'unique symbolで一意性を保証', 'ファクトリー関数を通さないと作れない', 'io-tsやzodでよく使われるパターン'],
'同じ構造でも区別する',
ARRAY['構造が同じでも混同を防ぎたいときに', '& { brand: unique symbol }でタグを付ける', 'UserIdとPostIdを別の型として扱える', 'バリデーション済みの値を表現するのにも使える'],
true),

('excess-property', '過剰プロパティチェック', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'オブジェクトリテラルの余分なプロパティをエラーに',
'オブジェクトリテラルを直接代入するとき、型にないプロパティがあるとエラーになります。',
'interface User {\n  name: string;\n}\n\n// オブジェクトリテラルは厳密チェック\nconst user: User = {\n  name: "田中",\n  // age: 30  // エラー！\n};\n\n// 変数経由だとOK（構造的型付け）\nconst obj = { name: "田中", age: 30 };\nconst user2: User = obj; // OK\n\n// as でもOK（非推奨）\nconst user3: User = { name: "田中", age: 30 } as User;',
'typo検出器',
ARRAY['オブジェクトリテラル直接代入時のみ発動', '変数経由だとバイパスされる', 'typo防止の安全機構', '構造的型付けとの違いを理解しろ'],
'typoを防ぐ安全機構',
ARRAY['オブジェクトリテラル直接代入時に厳密チェック', '定義にないプロパティがあるとエラー', 'typoによるバグを防止', '変数経由だとチェックされないので注意'],
true),

('const-assertion', 'constアサーション', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'リテラル型として固定',
'as constで値をリテラル型として推論させ、readonlyにします。',
'// 配列\nconst colors = ["red", "green", "blue"]; // string[]\nconst colorsConst = ["red", "green", "blue"] as const;\n// readonly ["red", "green", "blue"]\n\n// オブジェクト\nconst config = { host: "localhost", port: 3000 };\n// { host: string; port: number }\n\nconst configConst = { host: "localhost", port: 3000 } as const;\n// { readonly host: "localhost"; readonly port: 3000 }\n\n// enumの代替\nconst Status = {\n  Pending: "pending",\n  Done: "done"\n} as const;\ntype Status = typeof Status[keyof typeof Status]; // "pending" | "done"',
'値の凍結',
ARRAY['enumの代替としてよく使われる', 'readonlyかつリテラル型になる', 'typeofと組み合わせて型を抽出', 'Object.freeze()の型版のようなもの'],
'値をリテラル型に固定',
ARRAY['as constで値をリテラル型として推論', '配列はreadonlyタプルになる', 'オブジェクトは全プロパティがreadonly＆リテラル', 'enumの代替パターンとして人気'],
true),

('variance', '共変性・反変性', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'ジェネリクスの型互換性',
'ジェネリック型の型パラメータがどの位置で使われるかで、型の互換性が変わります。',
'// 共変（covariant）- 出力位置\ntype Producer<T> = () => T;\ntype AnimalProducer = Producer<Animal>;\ntype DogProducer = Producer<Dog>;\n// Dog extends Animal なら DogProducer extends AnimalProducer\n\n// 反変（contravariant）- 入力位置\ntype Consumer<T> = (x: T) => void;\ntype AnimalConsumer = Consumer<Animal>;\ntype DogConsumer = Consumer<Dog>;\n// Dog extends Animal なら AnimalConsumer extends DogConsumer\n\n// 不変（invariant）- 両方の位置\ntype Box<T> = { get(): T; set(x: T): void };\n// 厳密に同じ型でないと互換性なし',
'型の方向性',
ARRAY['関数の引数は反変、戻り値は共変', 'strictFunctionTypes: trueで正しく動作', 'この概念を理解すると型エラーの原因が分かる', '双変性（bivariant）はTS2.6以前の挙動'],
'ジェネリクスの型の方向',
ARRAY['出力位置（戻り値）は共変：具体的な型も代入可', '入力位置（引数）は反変：汎用的な型も代入可', '両方の位置で使われると不変', 'strictFunctionTypesで正しく動作'],
true),

('distributive-conditional', '分配条件型', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'union型に条件型を分配適用',
'条件型にunion型を渡すと、各メンバーに対して条件が適用されます。',
'type ToArray<T> = T extends any ? T[] : never;\n\ntype Result = ToArray<string | number>;\n// string[] | number[] （分配される）\n// (string | number)[] ではない！\n\n// 分配を防ぐ（タプルで包む）\ntype ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\ntype Result2 = ToArrayNonDist<string | number>;\n// (string | number)[]\n\n// Excludeは分配を活用\ntype MyExclude<T, U> = T extends U ? never : T;\ntype WithoutNull = MyExclude<string | null, null>; // string',
'条件の分配',
ARRAY['union型を渡すと各メンバーに分配される', '[T]で包むと分配を防げる', 'Exclude, Extractは分配を活用している', '直感に反する動作なので注意'],
'union型への条件型の適用',
ARRAY['条件型にunionを渡すと各メンバーに適用される', '分配条件型と呼ばれる', '[T]で包むと分配を防止できる', 'Exclude<T, U>等の実装に活用'],
true),

('recursive-type', '再帰型', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'自分自身を参照する型',
'型エイリアスが自分自身を参照して、ネストした構造を表現します。',
'// JSONの型\ntype Json =\n  | string\n  | number\n  | boolean\n  | null\n  | Json[]\n  | { [key: string]: Json };\n\n// ツリー構造\ntype TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};\n\n// DeepPartial\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\n};\n\n// DeepReadonly\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n};',
'自己参照型',
ARRAY['TS3.7から条件型での再帰が可能に', 'JSONやツリー構造の型定義に', '無限再帰に注意', 'DeepPartial, DeepReadonlyは自前で作る'],
'自分自身を参照する型',
ARRAY['ネストした構造を型で表現', 'JSON、ツリー構造などに', 'DeepPartialなど深いネストへの適用', '無限再帰にならないよう基底ケースが必要'],
true),

('module-augmentation', 'モジュール拡張', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'既存モジュールの型を拡張',
'declare moduleで既存のモジュールに型を追加します。ライブラリの型拡張に便利。',
'// Expressのreqを拡張\nimport { Request } from "express";\n\ndeclare module "express" {\n  interface Request {\n    user?: {\n      id: string;\n      name: string;\n    };\n  }\n}\n\n// これで req.user が使える\napp.get("/", (req: Request) => {\n  console.log(req.user?.name);\n});\n\n// グローバルオブジェクトの拡張\ndeclare global {\n  interface Window {\n    gtag: (...args: any[]) => void;\n  }\n}',
'型の後付け',
ARRAY['Expressのreq.user拡張は定番', '.d.tsファイルに書くのが慣例', 'declareブロック内で拡張', 'グローバル拡張はdeclare globalで'],
'既存の型を拡張',
ARRAY['既存モジュールの型に追加できる', 'Express等のreq拡張でよく使う', 'declare moduleで拡張先を指定', 'グローバルはdeclare globalで'],
true),

('strict-options', 'strictコンパイラオプション', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'beginner',
'型チェックを厳格化',
'tsconfig.jsonのstrictオプションで型チェックを厳しくします。新規プロジェクトでは必ず有効に。',
'// tsconfig.json\n{\n  "compilerOptions": {\n    "strict": true,  // 以下全てを有効化\n    // "strictNullChecks": true,\n    // "strictFunctionTypes": true,\n    // "strictBindCallApply": true,\n    // "strictPropertyInitialization": true,\n    // "noImplicitAny": true,\n    // "noImplicitThis": true,\n    // "alwaysStrict": true\n  }\n}\n\n// 個別に設定も可能\n{\n  "compilerOptions": {\n    "strict": true,\n    "strictPropertyInitialization": false  // これだけ無効\n  }\n}',
'型安全の守護神',
ARRAY['新規プロジェクトは必ずstrictをtrue', 'strictNullChecksがないTSはTSではない', '既存プロジェクトへの導入は段階的に', '個別オプションの意味を理解しろ'],
'型チェックを厳しくする',
ARRAY['strictをtrueにすると複数のチェックが有効に', '新規プロジェクトでは必ず有効にすべき', 'strictNullChecksは特に重要', '既存プロジェクトには段階的に導入'],
true),

('type-only-import', '型のみのimport', '44444444-4444-4444-4444-444444444444', 'a0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'型情報だけをimport',
'import typeで型のみをインポート。バンドルサイズの最適化やcircular dependency回避に。',
'// 型のみインポート\nimport type { User, Post } from "./types";\nimport type React from "react";\n\n// 値と型を混在\nimport { useState, type FC } from "react";\n\n// 型のみエクスポート\nexport type { User, Post };\n\n// re-export\nexport type { User } from "./types";\n\n// これらはコンパイル後に消える\n// バンドルサイズ削減に貢献',
'型だけimport',
ARRAY['コンパイル後のJSには残らない', 'isolatedModulesで必須になる場合あり', '循環参照の回避に役立つ', 'TS3.8で追加、4.5で混在記法が追加'],
'型情報のみをインポート',
ARRAY['import typeで型だけをインポート', 'コンパイル後のJSには含まれない', '循環参照の回避に役立つ', '値と型を{ value, type Type }で混在可能'],
true);

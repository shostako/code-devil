-- 020: SQL言語追加（80件）
-- 基本クエリからWindow関数、CTE等の実務レベルまで網羅

-- ===========================================
-- SQL 言語登録
-- ===========================================
INSERT INTO languages (id, slug, name, icon_url, description) VALUES
  ('55555555-5555-5555-5555-555555555555', 'sql', 'SQL', '/icons/sql.svg', 'データベース操作のための標準言語。SELECT, JOIN, インデックス等、データ操作の基礎から応用まで。');

-- ===========================================
-- SQL カテゴリ
-- ===========================================
INSERT INTO categories (id, language_id, slug, name, sort_order) VALUES
  ('b0111111-1111-1111-1111-111111111111', '55555555-5555-5555-5555-555555555555', 'basic-queries', '基本クエリ', 1),
  ('b0222222-2222-2222-2222-222222222222', '55555555-5555-5555-5555-555555555555', 'joins', '結合とサブクエリ', 2),
  ('b0333333-3333-3333-3333-333333333333', '55555555-5555-5555-5555-555555555555', 'aggregation', '集約とグループ化', 3),
  ('b0444444-4444-4444-4444-444444444444', '55555555-5555-5555-5555-555555555555', 'constraints', '制約とインデックス', 4),
  ('b0555555-5555-5555-5555-555555555555', '55555555-5555-5555-5555-555555555555', 'advanced', '高度な機能', 5);

-- ===========================================
-- SQL エントリ（80件）
-- ===========================================

-- =====================
-- 基本クエリ (20件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('select', 'SELECT', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'データを取得する',
'SELECTはテーブルからデータを取得する基本中の基本。列名やワイルドカード(*)を指定してデータを抽出します。',
'SELECT * FROM users;\nSELECT name, email FROM users;\nSELECT name AS user_name FROM users;',
'データ取得の王道',
ARRAY['SELECT * は本番で使うな、必要な列だけ指定しろ', 'ASで別名をつけられるが、可読性とのトレードオフ', '大文字小文字は区別しないが、慣習的に大文字', '複数列はカンマ区切り、最後にカンマつけるとエラー'],
'データを取得する基本',
ARRAY['SELECT 列名 FROM テーブル名 の形式', '*で全列、列名指定で特定の列だけ取得', 'AS で列に別名をつけられる', 'SQLの最も基本的な操作'],
true),

('where', 'WHERE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'条件でフィルタリング',
'WHERE句でレコードを条件で絞り込みます。比較演算子、AND、OR、IN、BETWEEN等を使えます。',
'SELECT * FROM users WHERE age >= 20;\nSELECT * FROM users WHERE name = ''田中'' AND age < 30;\nSELECT * FROM products WHERE price BETWEEN 100 AND 500;\nSELECT * FROM users WHERE status IN (''active'', ''pending'');',
'条件の番人',
ARRAY['文字列はシングルクォートで囲む', 'ANDとORの優先順位に注意、括弧で明示しろ', 'NULL判定は= NULLじゃなくIS NULL', 'インデックスがないと全件スキャンで遅い'],
'条件でデータを絞る',
ARRAY['WHERE 条件式でレコードを絞り込む', '=, !=, <, >, <=, >= で比較', 'AND, OR で複数条件を組み合わせ', 'IN, BETWEEN, LIKE で柔軟な条件指定'],
true),

('order-by', 'ORDER BY', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'結果を並び替え',
'ORDER BYで取得結果をソートします。ASC（昇順）、DESC（降順）を指定できます。',
'SELECT * FROM users ORDER BY age;\nSELECT * FROM users ORDER BY age DESC;\nSELECT * FROM users ORDER BY created_at DESC, name ASC;\nSELECT * FROM products ORDER BY price DESC LIMIT 10;',
'並び替え職人',
ARRAY['デフォルトはASC、DESCは明示的に書く', '複数列でソート可能、左から順に優先', 'NULL値の扱いはDBMSで異なる', 'インデックスがないと遅い'],
'データを並び替える',
ARRAY['ORDER BY 列名 で並び替え', 'ASC（昇順）、DESC（降順）を指定', '複数列指定で多段階ソート', 'LIMITと組み合わせて上位N件を取得'],
true),

('limit-offset', 'LIMIT / OFFSET', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'取得件数を制限',
'LIMITで取得件数を制限、OFFSETで開始位置を指定します。ページネーションの基本。',
'SELECT * FROM users LIMIT 10;\nSELECT * FROM users LIMIT 10 OFFSET 20;\nSELECT * FROM users ORDER BY id LIMIT 5;',
'ページネーション基礎',
ARRAY['OFFSETは大きな値だと遅い、カーソルベースを検討しろ', 'ORDER BYなしでLIMITは順序不定', 'MySQLではLIMIT 10, 20のような書き方もある', '全件数が欲しければCOUNT(*)を別途実行'],
'取得件数を制限する',
ARRAY['LIMIT Nで最大N件取得', 'OFFSET Mで開始位置を指定', 'ページネーションの実装に使う', 'ORDER BYと組み合わせて使うのが基本'],
true),

('insert', 'INSERT', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'データを挿入',
'INSERTで新しいレコードをテーブルに追加します。',
'INSERT INTO users (name, email) VALUES (''田中'', ''tanaka@example.com'');\nINSERT INTO users (name, email) VALUES\n  (''佐藤'', ''sato@example.com''),\n  (''鈴木'', ''suzuki@example.com'');\nINSERT INTO users (name) VALUES (''山田''); -- email省略（NULL）',
'データ追加係',
ARRAY['列名を省略すると全列を指定したことになる', 'VALUES複数でまとめて挿入できる', 'AUTO_INCREMENTの列は省略可能', 'RETURNING *でINSERTした値を取得（PostgreSQL）'],
'新しいデータを追加',
ARRAY['INSERT INTO テーブル名 (列) VALUES (値)', '複数レコードをまとめて挿入可能', '列を省略するとNULLまたはデフォルト値', 'AUTO_INCREMENT列は自動採番'],
true),

('update', 'UPDATE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'データを更新',
'UPDATEで既存レコードを更新します。WHERE句で対象を絞り込むのが重要。',
'UPDATE users SET name = ''新しい名前'' WHERE id = 1;\nUPDATE products SET price = price * 1.1 WHERE category = ''sale'';\nUPDATE users SET updated_at = NOW() WHERE id = 1;',
'データ書き換え人',
ARRAY['WHERE忘れると全件更新される恐怖', 'トランザクション内で実行しろ', '複数列の更新はカンマ区切り', 'SET句で現在値を参照できる'],
'既存データを更新',
ARRAY['UPDATE テーブル SET 列=値 WHERE 条件', 'WHERE句で更新対象を絞る', 'WHERE忘れると全件更新されるので注意', '複数列を一度に更新可能'],
true),

('delete', 'DELETE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'データを削除',
'DELETEでレコードを削除します。WHERE句で対象を絞るのが鉄則。',
'DELETE FROM users WHERE id = 1;\nDELETE FROM logs WHERE created_at < ''2023-01-01'';\nDELETE FROM temp_data; -- 全件削除（危険）',
'削除実行者',
ARRAY['WHERE忘れると全件削除で地獄', '論理削除（deleted_atフラグ）の方が安全', 'TRUNCATEの方が速いが復元不可', '外部キー制約に注意'],
'データを削除する',
ARRAY['DELETE FROM テーブル WHERE 条件', 'WHERE句で削除対象を絞る', 'WHERE忘れると全件削除されるので超注意', '物理削除より論理削除が安全'],
true),

('like', 'LIKE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'パターンマッチング',
'LIKEでワイルドカードを使った文字列検索。%は任意の文字列、_は任意の1文字。',
'SELECT * FROM users WHERE name LIKE ''田%''; -- 田で始まる\nSELECT * FROM users WHERE name LIKE ''%田%''; -- 田を含む\nSELECT * FROM users WHERE email LIKE ''%@gmail.com''; -- gmailアドレス\nSELECT * FROM products WHERE code LIKE ''A_B''; -- A何かB',
'曖昧検索の味方',
ARRAY['前方一致以外はインデックスが効かない', '全文検索の方が高機能', 'NOT LIKEもある', '大文字小文字の扱いはDBMS依存'],
'パターンで検索',
ARRAY['%で任意の文字列、_で任意の1文字', '前方一致、後方一致、部分一致が可能', '前方一致以外はインデックスが効きにくい', 'ILIKE（PostgreSQL）で大文字小文字無視'],
true),

('is-null', 'IS NULL / IS NOT NULL', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'NULL判定',
'NULLかどうかを判定します。= NULLは常にFALSEになるので、IS NULLを使います。',
'SELECT * FROM users WHERE email IS NULL;\nSELECT * FROM users WHERE email IS NOT NULL;\nSELECT * FROM products WHERE deleted_at IS NULL; -- 論理削除されていない',
'NULL検出器',
ARRAY['= NULLは動かない、IS NULLを使え', 'NULLは「値がない」状態', 'COALESCE()でデフォルト値を指定', '三値論理（TRUE/FALSE/UNKNOWN）に注意'],
'NULLを判定する',
ARRAY['IS NULLでNULLか判定', '= NULLは常にFALSEになるので使えない', 'IS NOT NULLで非NULLを判定', 'NULLは「値がない」状態を表す'],
true),

('distinct', 'DISTINCT', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'重複を除外',
'DISTINCTで重複した行を除外します。',
'SELECT DISTINCT city FROM users;\nSELECT DISTINCT category, status FROM products;\nSELECT COUNT(DISTINCT user_id) FROM orders;',
'重複削除マン',
ARRAY['パフォーマンスコストが高い', 'GROUP BYで代替できる場合もある', '複数列指定で全列の組み合わせがユニーク', 'DISTINCTは最初のSELECTに1回だけ'],
'重複を除外する',
ARRAY['重複した行を1つにまとめる', 'SELECT DISTINCTで使用', '複数列指定で組み合わせのユニーク化', 'COUNT(DISTINCT)で重複除外カウント'],
true),

('in', 'IN', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'値のリストで判定',
'INで複数の値のいずれかに一致するかを判定します。',
'SELECT * FROM users WHERE status IN (''active'', ''pending'');\nSELECT * FROM products WHERE id IN (1, 2, 3, 5, 8);\nSELECT * FROM users WHERE id NOT IN (SELECT user_id FROM banned);',
'リスト照合',
ARRAY['OR条件を簡潔に書ける', 'サブクエリも使えるが遅い場合あり', 'NOT INでNULLがあると罠', '大量の値だとパフォーマンス注意'],
'リストから選ぶ',
ARRAY['複数の値のいずれかに一致するか判定', 'OR条件を簡潔に書ける', 'サブクエリの結果も指定可能', 'NOT INで否定も可能'],
true),

('between', 'BETWEEN', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'beginner',
'範囲指定',
'BETWEENで値の範囲を指定します。境界値を含みます。',
'SELECT * FROM products WHERE price BETWEEN 100 AND 500;\nSELECT * FROM orders WHERE created_at BETWEEN ''2024-01-01'' AND ''2024-12-31'';\nSELECT * FROM users WHERE age NOT BETWEEN 20 AND 30;',
'範囲指定',
ARRAY['境界値を含むことに注意（以上・以下）', 'NOT BETWEENもある', '日付範囲で時刻に注意', '>= AND <=と同じ意味'],
'範囲で絞り込む',
ARRAY['値が範囲内かを判定（境界含む）', 'BETWEEN A AND Bで A以上B以下', '日付、数値の範囲指定に便利', 'NOT BETWEENで範囲外を指定'],
true),

('case', 'CASE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'syntax', 'intermediate',
'条件分岐',
'CASE式でSQLの中で条件分岐を行います。',
'SELECT\n  name,\n  CASE\n    WHEN age < 20 THEN ''未成年''\n    WHEN age < 65 THEN ''成人''\n    ELSE ''高齢者''\n  END AS age_group\nFROM users;\n\n-- 簡易CASE\nSELECT\n  name,\n  CASE status\n    WHEN ''active'' THEN ''有効''\n    WHEN ''inactive'' THEN ''無効''\n    ELSE ''不明''\n  END AS status_label\nFROM users;',
'条件分岐の達人',
ARRAY['検索CASE（WHEN条件）と簡易CASE（値比較）の2種類', 'ENDを忘れるな', 'ELSEを省略するとNULLになる', 'ORDER BYでも使える'],
'条件で値を変える',
ARRAY['CASE WHEN 条件 THEN 値 で分岐', 'ELSE で該当なしの場合を指定', '検索CASEと簡易CASEの2形式', 'SELECT, WHERE, ORDER BYで使える'],
true),

('coalesce', 'COALESCE', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'intermediate',
'最初の非NULL値を返す',
'COALESCEは引数の中で最初のNULLでない値を返します。',
'SELECT COALESCE(email, ''なし'') FROM users;\nSELECT COALESCE(nickname, name, ''名前なし'') FROM users;\nSELECT name, COALESCE(age, 0) AS age FROM users;',
'NULL回避',
ARRAY['デフォルト値を設定する定番', '複数の列から最初の非NULLを取る', 'IFNULLやNVLはDBMS固有', '引数は全て同じ型である必要がある'],
'NULLの代わりに値を返す',
ARRAY['最初の非NULL値を返す', 'NULL時のデフォルト値設定に便利', '複数引数を指定可能', '全部NULLならNULLを返す'],
true),

('concat', 'CONCAT / ||', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'beginner',
'文字列を結合',
'CONCATまたは||演算子で文字列を結合します。',
'SELECT CONCAT(last_name, '' '', first_name) AS full_name FROM users;\nSELECT first_name || '' '' || last_name FROM users; -- PostgreSQL\nSELECT CONCAT(''User: '', name, '' ('', email, '')'') FROM users;',
'文字列くっつけ',
ARRAY['NULLが含まれると全体がNULLになる（||演算子）', 'CONCAT関数はNULLを空文字として扱う', 'MySQLとPostgreSQLで挙動が違う', 'CONCAT_WSは区切り文字を指定できる'],
'文字列を連結する',
ARRAY['複数の文字列を1つに結合', 'CONCAT(A, B, C)で連結', '||演算子も使える（DB依存）', 'CONCAT_WSで区切り文字を指定'],
true),

('cast', 'CAST', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'intermediate',
'型変換',
'CASTで値の型を変換します。',
'SELECT CAST(price AS INTEGER) FROM products;\nSELECT CAST(created_at AS DATE) FROM orders;\nSELECT CAST(''123'' AS INTEGER) + 1;\nSELECT price::INTEGER FROM products; -- PostgreSQL',
'型変換器',
ARRAY['::記法はPostgreSQL独自', '変換できない値はエラーになる', '暗黙の型変換に頼るな', 'TO_DATE, TO_NUMBERなどDBMS固有関数もある'],
'型を変換する',
ARRAY['CAST(値 AS 型)で型変換', '文字列→数値、数値→文字列など', '変換できない場合はエラー', '::記法はPostgreSQLの省略形'],
true),

('now', 'NOW / CURRENT_TIMESTAMP', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'beginner',
'現在日時を取得',
'NOW()またはCURRENT_TIMESTAMPで現在の日時を取得します。',
'SELECT NOW();\nSELECT CURRENT_TIMESTAMP;\nINSERT INTO logs (message, created_at) VALUES (''test'', NOW());\nSELECT * FROM events WHERE created_at > NOW() - INTERVAL ''1 day'';',
'時刻取得',
ARRAY['NOW()とCURRENT_TIMESTAMPは同じ', 'CURRENT_DATEで日付のみ、CURRENT_TIMEで時刻のみ', 'タイムゾーン注意', 'トランザクション内では同じ値を返す'],
'現在の日時を取得',
ARRAY['現在の日時を返す', 'NOW()とCURRENT_TIMESTAMPは同じ', 'タイムスタンプの記録に使う', 'CURRENT_DATEで日付のみ取得'],
true),

('date-functions', '日付関数', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'intermediate',
'日付の操作',
'日付の加減算、抽出、フォーマット等の関数群。',
'-- 日付加算\nSELECT created_at + INTERVAL ''1 day'' FROM orders;\n-- 日付差分\nSELECT AGE(NOW(), birth_date) FROM users; -- PostgreSQL\nSELECT DATEDIFF(NOW(), birth_date) FROM users; -- MySQL\n-- 部分抽出\nSELECT EXTRACT(YEAR FROM created_at) FROM orders;\nSELECT DATE_PART(''month'', created_at) FROM orders;',
'日付操作',
ARRAY['DBMS間で関数名が大きく異なる', 'タイムゾーンの扱いに注意', 'INTERVALの書き方もDBMS依存', '日付計算はORMに任せた方が無難'],
'日付を操作する',
ARRAY['INTERVAL で日付の加減算', 'EXTRACT で年月日を抽出', 'DATEDIFF で日付差分', 'DBMSによって関数名が異なる'],
true),

('string-functions', '文字列関数', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'beginner',
'文字列操作',
'文字列の長さ、切り出し、置換、大小文字変換等の関数群。',
'SELECT LENGTH(name) FROM users;\nSELECT UPPER(name), LOWER(email) FROM users;\nSELECT SUBSTRING(code, 1, 3) FROM products;\nSELECT REPLACE(description, ''old'', ''new'') FROM products;\nSELECT TRIM(''  hello  '');\nSELECT POSITION(''@'' IN email) FROM users;',
'文字列いじり',
ARRAY['SUBSTR, SUBSTRING, MIDなど名前がDBMSで異なる', 'LENGTHは文字数、OCTET_LENGTHはバイト数', 'マルチバイト文字の扱いに注意', '正規表現はREGEXP系関数'],
'文字列を操作する',
ARRAY['LENGTH で長さ、UPPER/LOWERで大小変換', 'SUBSTRINGで部分文字列抽出', 'REPLACEで置換、TRIMで空白削除', 'DBMSによって関数名が異なる'],
true),

('numeric-functions', '数値関数', '55555555-5555-5555-5555-555555555555', 'b0111111-1111-1111-1111-111111111111', 'function', 'beginner',
'数値の演算・丸め',
'絶対値、丸め、切り上げ・切り捨て等の数値操作関数。',
'SELECT ABS(-10); -- 10\nSELECT ROUND(123.456, 2); -- 123.46\nSELECT CEIL(123.1), FLOOR(123.9); -- 124, 123\nSELECT MOD(10, 3); -- 1\nSELECT POWER(2, 3); -- 8\nSELECT SQRT(16); -- 4',
'数値計算',
ARRAY['ROUND, CEIL, FLOORの使い分け', 'MODは%演算子でも書ける', 'PostgreSQLとMySQLで関数名が微妙に違う', 'RANDOM()で乱数（非推奨）'],
'数値を計算する',
ARRAY['ABS で絶対値、ROUND で四捨五入', 'CEIL で切り上げ、FLOOR で切り捨て', 'MOD で剰余、POWER で累乗', 'SQRT で平方根'],
true);

-- =====================
-- 結合とサブクエリ (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('inner-join', 'INNER JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'両方に存在するレコードを結合',
'INNER JOINは両テーブルに一致するレコードだけを結合します。',
'SELECT users.name, orders.total\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n\nSELECT u.name, o.total\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.total > 1000;',
'両側マッチング',
ARRAY['単にJOINと書いても同じ意味', 'ON句でJOIN条件を指定', '複数テーブルのJOINは順序が重要', 'インデックスがないと激遅'],
'両方にあるデータを結合',
ARRAY['両テーブルに一致するレコードだけ', 'ON で結合条件を指定', 'テーブル名にエイリアスをつけると簡潔', 'JOINとINNER JOINは同じ'],
true),

('left-join', 'LEFT JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'左テーブルを基準に結合',
'LEFT JOINは左テーブルの全レコードと、一致する右テーブルのレコードを結合。一致しない場合はNULL。',
'SELECT users.name, orders.total\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id;\n\n-- 注文がないユーザーを抽出\nSELECT users.name\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id\nWHERE orders.id IS NULL;',
'左全出し',
ARRAY['LEFT OUTER JOINとも書く', '右側が存在しない場合はNULL', 'IS NULLで「結合できなかったレコード」を抽出', 'パフォーマンスはINNER JOINより劣る'],
'左側を全部残す',
ARRAY['左テーブルの全レコードを保持', '右側に一致がなければNULL', 'LEFT OUTER JOINとも書く', '「注文していないユーザー」等の検索に'],
true),

('right-join', 'RIGHT JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'右テーブルを基準に結合',
'RIGHT JOINは右テーブルの全レコードを保持。LEFT JOINの逆。',
'SELECT users.name, orders.total\nFROM orders\nRIGHT JOIN users ON users.id = orders.user_id;',
'右全出し',
ARRAY['LEFT JOINで書き直せる（テーブル順を入れ替え）', 'RIGHT JOINを使う理由はほぼない', 'LEFT JOINに統一するのが読みやすい', 'PostgreSQLでは使える'],
'右側を全部残す',
ARRAY['右テーブルの全レコードを保持', 'LEFT JOINの逆', '実務ではLEFT JOINに統一する方が読みやすい', 'テーブル順を変えてLEFT JOINで書ける'],
true),

('full-outer-join', 'FULL OUTER JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'両方の全レコードを結合',
'FULL OUTER JOINは両テーブルの全レコードを保持。一致しない部分はNULL。',
'SELECT users.name, orders.total\nFROM users\nFULL OUTER JOIN orders ON users.id = orders.user_id;',
'全部出し',
ARRAY['MySQLは未対応', 'LEFT JOIN UNION RIGHT JOINで代替可能', '使う場面は稀', 'マスタ同期の差分抽出に使える'],
'両方の全データを保持',
ARRAY['両テーブルの全レコードを保持', '一致しない部分はNULL', 'MySQLは未対応', 'LEFT UNION RIGHTで代替可能'],
true),

('cross-join', 'CROSS JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'直積（全組み合わせ）',
'CROSS JOINは両テーブルの全組み合わせを生成します。',
'SELECT colors.name, sizes.name\nFROM colors\nCROSS JOIN sizes;\n\n-- カンマでも書ける（非推奨）\nSELECT * FROM colors, sizes;',
'組み合わせ爆発',
ARRAY['結果の行数 = 左の行数 × 右の行数', '意図せずCROSS JOINになると大惨事', 'ON句は書かない', 'マスタテーブルの組み合わせ生成に使う'],
'全組み合わせを生成',
ARRAY['両テーブルの全組み合わせ（直積）', '結果は行数の掛け算', 'ON句は不要', 'カラーとサイズの全組み合わせなど'],
true),

('self-join', 'SELF JOIN', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'同じテーブル同士を結合',
'SELF JOINは同じテーブルを別名で結合。階層データや比較に使います。',
'-- 社員とその上司\nSELECT e.name AS employee, m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n\n-- 同じカテゴリの商品を比較\nSELECT p1.name, p2.name\nFROM products p1\nJOIN products p2 ON p1.category_id = p2.category_id\nWHERE p1.id < p2.id;',
'自己結合',
ARRAY['エイリアス必須', '階層構造（親子関係）の表現に', '組み合わせを作る時にも使える', 'id < idで重複を避ける'],
'同じテーブルを結合',
ARRAY['同じテーブルに別名をつけて結合', '階層構造の表現に便利', '社員と上司、親カテゴリと子カテゴリなど', 'エイリアスが必須'],
true),

('subquery-where', 'サブクエリ（WHERE）', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'WHERE句内でクエリを使う',
'WHERE句の中にSELECT文を書いて条件を動的に作ります。',
'-- 平均以上の価格\nSELECT * FROM products\nWHERE price > (SELECT AVG(price) FROM products);\n\n-- 注文があるユーザー\nSELECT * FROM users\nWHERE id IN (SELECT user_id FROM orders);',
'入れ子クエリ',
ARRAY['パフォーマンスが悪い場合が多い', 'JOINで書き直せないか検討しろ', '単一値を返すサブクエリとリストを返すサブクエリ', 'EXISTSの方が速い場合もある'],
'クエリの中にクエリ',
ARRAY['WHERE句の中にSELECTを書く', '動的な条件を作れる', 'JOINより直感的だが遅い場合あり', 'IN, EXISTS, 比較演算子と組み合わせる'],
true),

('subquery-from', 'サブクエリ（FROM）', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'FROM句でサブクエリを使う',
'FROM句にサブクエリを書いて仮想テーブルを作ります。',
'SELECT category, AVG(price) AS avg_price\nFROM (\n  SELECT category, price\n  FROM products\n  WHERE status = ''active''\n) AS active_products\nGROUP BY category;\n\n-- ランキング\nSELECT * FROM (\n  SELECT name, price,\n    ROW_NUMBER() OVER (ORDER BY price DESC) AS rank\n  FROM products\n) AS ranked\nWHERE rank <= 10;',
'仮想テーブル',
ARRAY['エイリアス必須', 'WITH句（CTE）の方が読みやすい', 'ネストすると地獄', '一時的なデータ整形に便利'],
'仮想的なテーブルを作る',
ARRAY['FROM句にSELECTを書く', 'エイリアスが必須', '複雑な集計の中間結果を作る', 'CTE（WITH句）の方が読みやすい'],
true),

('subquery-select', 'スカラサブクエリ', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'SELECT句でサブクエリを使う',
'SELECT句にサブクエリを書いて、各行に対してサブクエリを実行します。',
'SELECT\n  name,\n  (SELECT COUNT(*) FROM orders WHERE orders.user_id = users.id) AS order_count\nFROM users;\n\nSELECT\n  product_name,\n  price,\n  (SELECT AVG(price) FROM products) AS avg_price\nFROM products;',
'列計算',
ARRAY['行ごとにサブクエリが実行されるので遅い', '単一値しか返せない', 'LEFT JOINで書き直せないか検討', '定数を返すサブクエリなら問題ない'],
'列の値をサブクエリで計算',
ARRAY['SELECT句にサブクエリを書く', '単一値を返す必要がある', '行ごとに実行されるので遅い', 'JOINやWindow関数で代替できないか検討'],
true),

('exists', 'EXISTS', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'レコードの存在確認',
'EXISTSは条件に合うレコードが存在するかを判定します。INより高速な場合が多い。',
'-- 注文があるユーザー\nSELECT * FROM users u\nWHERE EXISTS (\n  SELECT 1 FROM orders o WHERE o.user_id = u.id\n);\n\n-- 注文がないユーザー\nSELECT * FROM users u\nWHERE NOT EXISTS (\n  SELECT 1 FROM orders o WHERE o.user_id = u.id\n);',
'存在チェック',
ARRAY['INより速い場合が多い', 'SELECT 1でもSELECT *でも同じ', '最初の1件見つかった時点で終了', 'NOT EXISTSで「存在しない」を検索'],
'存在するか確認',
ARRAY['サブクエリに一致するレコードがあるか判定', 'INより高速な場合が多い', '1件でも見つかればtrue', 'NOT EXISTSで否定も可能'],
true),

('union', 'UNION', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'クエリ結果を結合',
'UNIONは複数のSELECT結果を縦に結合します。重複は自動で除外。',
'SELECT name FROM users\nUNION\nSELECT name FROM admins;\n\n-- 重複を残す\nSELECT name FROM users\nUNION ALL\nSELECT name FROM admins;',
'結果の結合',
ARRAY['列数と型が一致する必要がある', 'UNION ALLは重複を残す（高速）', '重複除外が不要ならALLを使え', 'ORDER BYは最後に1回だけ'],
'複数クエリの結果を統合',
ARRAY['複数のSELECTを縦に結合', '重複は自動で除外される', 'UNION ALLで重複を残す（高速）', '列数と型を揃える必要がある'],
true),

('intersect', 'INTERSECT', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'共通部分を抽出',
'INTERSECTは複数のクエリの共通部分（積集合）を返します。',
'SELECT user_id FROM orders\nINTERSECT\nSELECT user_id FROM reviews;',
'積集合',
ARRAY['MySQLは未対応', 'INNER JOINやEXISTSで代替可能', '使う場面は稀', 'DISTINCTが自動で適用される'],
'共通するレコードを抽出',
ARRAY['複数クエリの共通部分（積集合）', 'MySQLは未対応', 'INNER JOINで代替可能', '重複は自動で除外'],
true),

('except', 'EXCEPT / MINUS', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'intermediate',
'差集合を抽出',
'EXCEPTは1つ目のクエリから2つ目のクエリの結果を除外します。',
'SELECT user_id FROM users\nEXCEPT\nSELECT user_id FROM banned_users;\n\n-- Oracleではm MINUSを使う\nSELECT user_id FROM users\nMINUS\nSELECT user_id FROM banned_users;',
'差集合',
ARRAY['MySQLは未対応', 'NOT IN, NOT EXISTSで代替可能', 'OracleではMINUS', '重複は自動で除外'],
'片方だけのレコードを抽出',
ARRAY['1つ目から2つ目を引いた差集合', 'MySQLは未対応（NOT INで代替）', 'OracleではMINUS', '重複は自動で除外'],
true),

('any-all', 'ANY / ALL', '55555555-5555-5555-5555-555555555555', 'b0222222-2222-2222-2222-222222222222', 'syntax', 'advanced',
'サブクエリの結果と比較',
'ANYは1つでも条件を満たせばtrue、ALLは全て満たす必要があります。',
'-- いずれかの注文額より大きい\nSELECT * FROM products\nWHERE price > ANY (SELECT total FROM orders);\n\n-- 全ての注文額より大きい\nSELECT * FROM products\nWHERE price > ALL (SELECT total FROM orders);',
'ANY/ALL比較',
ARRAY['ANYはINやEXISTSで書き直せる', 'ALLはMAX/MINで代替可能', '使う場面は稀', 'SOMEはANYと同じ意味'],
'複数値との比較',
ARRAY['ANY: 1つでも条件を満たせばtrue', 'ALL: 全て条件を満たす必要', '> ANY で「いずれかより大きい」', '> ALL で「全てより大きい」'],
true);

-- =====================
-- 集約とグループ化 (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('count', 'COUNT', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'beginner',
'レコード数を数える',
'COUNTは条件に合うレコードの数を返します。',
'SELECT COUNT(*) FROM users;\nSELECT COUNT(DISTINCT city) FROM users;\nSELECT COUNT(email) FROM users; -- NULLは数えない\nSELECT category, COUNT(*) FROM products GROUP BY category;',
'カウンター',
ARRAY['COUNT(*)とCOUNT(列)の違い', 'NULLは数えられない', 'COUNT(DISTINCT)で重複除外カウント', 'COUNT(1)はCOUNT(*)と同じ'],
'件数を数える',
ARRAY['COUNT(*)で全件数', 'COUNT(列)はNULLを除外', 'COUNT(DISTINCT)で重複除外', 'GROUP BYと組み合わせてグループ別カウント'],
true),

('sum', 'SUM', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'beginner',
'合計を計算',
'SUMは数値列の合計を計算します。',
'SELECT SUM(price) FROM products;\nSELECT category, SUM(price) FROM products GROUP BY category;\nSELECT SUM(CASE WHEN status = ''active'' THEN 1 ELSE 0 END) AS active_count FROM users;',
'合計計算',
ARRAY['NULLは無視される', '文字列には使えない', 'CASE式と組み合わせて条件付き合計', 'オーバーフローに注意'],
'合計を計算',
ARRAY['数値列の合計を返す', 'NULLは無視される', 'GROUP BYで グループ別の合計', 'CASE式で条件付き合計も可能'],
true),

('avg', 'AVG', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'beginner',
'平均を計算',
'AVGは数値列の平均を計算します。',
'SELECT AVG(price) FROM products;\nSELECT category, AVG(price) FROM products GROUP BY category;\nSELECT AVG(CAST(score AS FLOAT)) FROM tests;',
'平均計算',
ARRAY['NULLは無視される', '整数同士の除算は整数になるDBMSもある', 'CASTで浮動小数点に変換', '0で割る場合はNULL'],
'平均を計算',
ARRAY['数値列の平均を返す', 'NULLは無視される', '整数型の場合は結果も整数になる場合あり', 'CASTで型変換して小数を保持'],
true),

('max-min-sql', 'MAX / MIN', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'beginner',
'最大値・最小値',
'MAXは最大値、MINは最小値を返します。数値、文字列、日付に使えます。',
'SELECT MAX(price), MIN(price) FROM products;\nSELECT category, MAX(price) FROM products GROUP BY category;\nSELECT MAX(created_at) FROM orders;',
'最大最小',
ARRAY['文字列には辞書順、日付には最新/最古', 'NULLは無視される', 'インデックスがあれば高速', 'MAX/MIN以外の列も取りたい場合は工夫が必要'],
'最大・最小を取得',
ARRAY['MAXで最大値、MINで最小値', '数値、文字列、日付に使える', 'NULLは無視される', 'GROUP BYでグループ別の最大最小'],
true),

('group-by', 'GROUP BY', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'グループ化して集約',
'GROUP BYで指定した列の値ごとにレコードをグループ化し、集約関数を適用します。',
'SELECT category, COUNT(*), AVG(price)\nFROM products\nGROUP BY category;\n\nSELECT category, status, COUNT(*)\nFROM products\nGROUP BY category, status\nORDER BY category, status;',
'グループ集約',
ARRAY['SELECT句にはGROUP BY列か集約関数のみ', '複数列でグループ化可能', 'WHEREで絞ってからGROUP BY', 'HAVINGで集約後の絞り込み'],
'グループごとに集計',
ARRAY['指定した列でグループ化', '集約関数（COUNT, SUM等）と組み合わせる', 'SELECT句はGROUP BY列か集約関数のみ', '複数列でのグループ化も可能'],
true),

('having', 'HAVING', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'グループ化後の条件',
'HAVINGはGROUP BYの結果に対して条件を指定します。集約関数の結果で絞り込めます。',
'SELECT category, COUNT(*) AS count\nFROM products\nGROUP BY category\nHAVING COUNT(*) > 10;\n\nSELECT user_id, SUM(total) AS total_spent\nFROM orders\nGROUP BY user_id\nHAVING SUM(total) > 10000;',
'集約後フィルター',
ARRAY['WHEREは集約前、HAVINGは集約後', '集約関数の結果で絞り込める', 'パフォーマンス的にはWHEREで先に絞る', 'エイリアスが使えるDBMSもある'],
'集約後に条件で絞る',
ARRAY['GROUP BY後の結果を絞り込む', '集約関数の結果で条件指定できる', 'WHEREは集約前、HAVINGは集約後', 'COUNT(*) > 10 等の条件に使う'],
true),

('group-concat', 'GROUP_CONCAT / STRING_AGG', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'intermediate',
'グループの値を文字列結合',
'グループ化した結果を1つの文字列に結合します。',
'-- MySQL\nSELECT category,\n  GROUP_CONCAT(name ORDER BY name SEPARATOR '', '')\nFROM products\nGROUP BY category;\n\n-- PostgreSQL\nSELECT category,\n  STRING_AGG(name, '', '' ORDER BY name)\nFROM products\nGROUP BY category;',
'文字列集約',
ARRAY['DBMS間で関数名が異なる', 'ORDERで順序指定可能', '結果の長さ上限に注意', '区切り文字を指定できる'],
'グループの値を結合',
ARRAY['グループ内の値を文字列に結合', 'MySQLはGROUP_CONCAT', 'PostgreSQLはSTRING_AGG', '区切り文字と順序を指定可能'],
true),

('rollup', 'ROLLUP', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'advanced',
'小計と総計を作成',
'ROLLUPは階層的な小計・総計を自動生成します。',
'SELECT category, status, COUNT(*)\nFROM products\nGROUP BY ROLLUP(category, status);\n\n-- 結果:\n-- カテゴリA, ステータス1, 10\n-- カテゴリA, NULL, 30  （カテゴリAの小計）\n-- NULL, NULL, 100       （総計）',
'階層集計',
ARRAY['OLAP系の集計に使う', 'NULLが小計・総計の印', 'COALESCEで「合計」等のラベルを付ける', 'MySQLも対応している'],
'小計と総計を自動生成',
ARRAY['階層的な集計結果を作る', '小計行と総計行が自動で追加される', 'NULLが小計・総計の目印', 'レポート作成に便利'],
true),

('cube', 'CUBE', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'advanced',
'全組み合わせの集計',
'CUBEは指定した列の全組み合わせで集計します。',
'SELECT category, status, COUNT(*)\nFROM products\nGROUP BY CUBE(category, status);',
'全組み合わせ集計',
ARRAY['ROLLUPより更に多くの小計が出る', '列数が多いと組み合わせ爆発', 'クロス集計に使う', 'MySQLは未対応'],
'全パターンで集計',
ARRAY['指定列の全組み合わせで集計', 'ROLLUPより更に多くの小計', '列数が増えると爆発的に増える', 'クロス集計表の作成に'],
true),

('grouping', 'GROUPING', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'advanced',
'集計行を識別',
'GROUPING関数はROLLUP/CUBEで生成された小計行を識別します。',
'SELECT\n  COALESCE(category, ''全カテゴリ'') AS category,\n  COALESCE(status, ''全ステータス'') AS status,\n  COUNT(*),\n  GROUPING(category) AS is_cat_total,\n  GROUPING(status) AS is_status_total\nFROM products\nGROUP BY ROLLUP(category, status);',
'集計行判定',
ARRAY['ROLLUP/CUBEと組み合わせる', '小計行は1、通常行は0を返す', 'COALESCEでラベルを付ける', 'レポート生成時に便利'],
'小計行かどうか判定',
ARRAY['ROLLUP/CUBEで生成された行を識別', '小計・総計行は1、通常行は0を返す', 'COALESCEと組み合わせてラベル表示', 'レポート作成の定番'],
true),

('partition', 'PARTITION BY（基礎）', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'Window関数のグループ指定',
'PARTITION BYはWindow関数内でグループを指定します。GROUP BYと違い全行が保持されます。',
'SELECT\n  name,\n  category,\n  price,\n  AVG(price) OVER (PARTITION BY category) AS category_avg\nFROM products;\n\nSELECT\n  name,\n  price,\n  AVG(price) OVER () AS overall_avg\nFROM products;',
'Window関数のグループ',
ARRAY['GROUP BYと違い全行が残る', '省略すると全体が1つのパーティション', 'Window関数専用、通常のSELECTでは使えない', 'OVERと必ずセット'],
'グループ内での計算',
ARRAY['Window関数でグループを指定', 'GROUP BYと違い全行が保持される', 'グループごとの平均等を各行に表示', 'OVER句の中で使用'],
true),

('filter', 'FILTER', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'syntax', 'intermediate',
'集約関数に条件を付ける',
'FILTER句で集約関数に条件を指定します。CASE式より簡潔に書けます。',
'SELECT\n  category,\n  COUNT(*) FILTER (WHERE status = ''active'') AS active_count,\n  COUNT(*) FILTER (WHERE status = ''inactive'') AS inactive_count\nFROM products\nGROUP BY category;',
'条件付き集計',
ARRAY['PostgreSQLの機能', 'MySQLは未対応（CASE式で代替）', 'Window関数でも使える', 'クロス集計を簡潔に書ける'],
'条件付きで集約',
ARRAY['集約関数に条件を追加', 'CASE式より簡潔に書ける', 'PostgreSQL等で対応', 'MySQLはCASE式で代替'],
true),

('array-agg', 'ARRAY_AGG', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'intermediate',
'グループの値を配列に',
'ARRAY_AGGはグループ内の値を配列として返します。',
'SELECT\n  category,\n  ARRAY_AGG(name ORDER BY price DESC) AS product_names\nFROM products\nGROUP BY category;',
'配列集約',
ARRAY['PostgreSQL, SQLiteなどで対応', 'MySQLは未対応（JSON_ARRAYGGで代替）', 'ORDERで順序指定可能', '配列型を返す'],
'値を配列にまとめる',
ARRAY['グループ内の値を配列として返す', 'PostgreSQL等で対応', 'ORDERで順序指定可能', 'MySQLはJSON_ARRAYAGGで代替'],
true),

('json-agg', 'JSON_AGG / JSON_ARRAYAGG', '55555555-5555-5555-5555-555555555555', 'b0333333-3333-3333-3333-333333333333', 'function', 'intermediate',
'グループの値をJSON配列に',
'グループ内の値をJSON配列として返します。',
'-- PostgreSQL\nSELECT category,\n  JSON_AGG(JSON_BUILD_OBJECT(\n    ''name'', name,\n    ''price'', price\n  )) AS products\nFROM products\nGROUP BY category;\n\n-- MySQL\nSELECT category,\n  JSON_ARRAYAGG(name) AS product_names\nFROM products\nGROUP BY category;',
'JSON集約',
ARRAY['DBMSで関数名が異なる', 'APIレスポンス生成に便利', 'ネストしたJSONも作れる', 'JSON_OBJECT_AGGでオブジェクトも作れる'],
'値をJSON配列に',
ARRAY['グループ内の値をJSON配列として返す', 'APIレスポンス用のJSON生成に', 'DBMS毎に関数名が異なる', 'JSON_OBJECT_AGGでオブジェクトも作成可'],
true);

-- =====================
-- 制約とインデックス (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('primary-key', 'PRIMARY KEY', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'主キー制約',
'PRIMARY KEYはテーブルの各レコードを一意に識別する列を指定します。',
'CREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) UNIQUE NOT NULL\n);\n\n-- 複合主キー\nCREATE TABLE order_items (\n  order_id INTEGER,\n  product_id INTEGER,\n  quantity INTEGER,\n  PRIMARY KEY (order_id, product_id)\n);',
'一意識別子',
ARRAY['NULLは許可されない', 'UNIQUEインデックスが自動作成', '複合主キーも可能', '1テーブルに1つだけ'],
'レコードを一意に識別',
ARRAY['各レコードを一意に識別する列', 'NULLは許可されない', '自動でインデックスが作られる', '1テーブルに1つだけ定義可能'],
true),

('foreign-key', 'FOREIGN KEY', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'外部キー制約',
'FOREIGN KEYは他テーブルのPRIMARY KEYを参照し、参照整合性を保証します。',
'CREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id),\n  total DECIMAL(10, 2)\n);\n\n-- ON DELETE/UPDATE動作指定\nCREATE TABLE posts (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id)\n    ON DELETE CASCADE\n    ON UPDATE CASCADE\n);',
'参照整合性',
ARRAY['ON DELETE CASCADEで親削除時に子も削除', 'RESTRICTでデフォルトは削除禁止', 'SET NULLでNULLに設定', 'パフォーマンスコストあり'],
'他テーブルを参照',
ARRAY['他テーブルのレコードを参照', '参照先が存在しないとエラー', 'ON DELETE CASCADEで連鎖削除', 'データの整合性を保証'],
true),

('unique', 'UNIQUE', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'一意制約',
'UNIQUEは列の値が重複しないことを保証します。',
'CREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) UNIQUE,\n  username VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- 複合UNIQUE\nCREATE TABLE enrollments (\n  user_id INTEGER,\n  course_id INTEGER,\n  UNIQUE (user_id, course_id)\n);',
'重複禁止',
ARRAY['NULLは複数OK（PostgreSQL）', 'インデックスが自動作成', '複合UNIQUEも可能', 'PRIMARY KEYとの違いを理解しろ'],
'重複を防ぐ',
ARRAY['列の値が重複しないことを保証', 'メールアドレスやユーザー名に使う', '自動でインデックスが作られる', 'NULLは複数許可される（DB依存）'],
true),

('not-null', 'NOT NULL', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'NULL禁止制約',
'NOT NULLは列にNULLを許可しません。',
'CREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  email VARCHAR(255) NOT NULL,\n  bio TEXT -- NULLを許可\n);',
'NULL禁止',
ARRAY['デフォルトはNULL許可', 'PRIMARY KEYは暗黙的にNOT NULL', 'NOT NULL制約を後から追加するのは大変', '必須項目には必ず付けろ'],
'NULLを禁止',
ARRAY['NULLを許可しない', '必須項目に設定', 'PRIMARY KEYは暗黙的にNOT NULL', 'デフォルトはNULL許可'],
true),

('check', 'CHECK', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'値の範囲制約',
'CHECK制約で列の値に条件を指定します。',
'CREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  price DECIMAL(10, 2) CHECK (price >= 0),\n  stock INTEGER CHECK (stock >= 0)\n);\n\n-- テーブルレベルのCHECK\nCREATE TABLE users (\n  age INTEGER,\n  birth_year INTEGER,\n  CHECK (age >= 0 AND age <= 150),\n  CHECK (birth_year > 1900)\n);',
'値の検証',
ARRAY['複雑な条件も書ける', 'パフォーマンスコストあり', 'アプリ側でも検証すべき', 'MySQLは実行されない（構文だけ受け付ける）'],
'値の条件を指定',
ARRAY['列の値に条件を設定', '価格は0以上、年齢は0〜150など', 'アプリ側のバリデーションと併用', 'MySQLは動作しないので注意'],
true),

('default', 'DEFAULT', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'デフォルト値',
'DEFAULT句で列のデフォルト値を指定します。',
'CREATE TABLE posts (\n  id SERIAL PRIMARY KEY,\n  status VARCHAR(20) DEFAULT ''draft'',\n  is_published BOOLEAN DEFAULT false,\n  created_at TIMESTAMP DEFAULT NOW()\n);',
'初期値設定',
ARRAY['INSERT時に省略するとデフォルト値', '関数（NOW()等）も指定可能', 'NOT NULLと組み合わせると安全', 'NULL DEFAULTは省略と同じ'],
'初期値を設定',
ARRAY['列のデフォルト値を指定', 'INSERT時に省略すると使われる', 'NOW()等の関数も指定可能', 'NOT NULLと併用で必ず値が入る'],
true),

('index-create', 'CREATE INDEX', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'インデックス作成',
'CREATE INDEXで検索を高速化するインデックスを作成します。',
'CREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_products_category ON products(category);\n\n-- 複合インデックス\nCREATE INDEX idx_orders_user_date ON orders(user_id, created_at);\n\n-- 部分インデックス（PostgreSQL）\nCREATE INDEX idx_active_users ON users(email)\n  WHERE status = ''active'';',
'高速化の要',
ARRAY['WHERE, JOIN, ORDER BYで使う列に', '複合インデックスは列順が重要', 'インデックスが多すぎると更新が遅くなる', 'EXPLAINで効果を確認しろ'],
'検索を高速化',
ARRAY['検索を高速化するインデックスを作成', 'WHERE句やJOINで使う列に', '複合インデックスは列の順序が重要', '更新も遅くなるので適度に'],
true),

('unique-index', 'UNIQUE INDEX', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'一意インデックス',
'UNIQUE INDEXは重複を防ぎつつ検索も高速化します。',
'CREATE UNIQUE INDEX idx_users_email ON users(email);\nCREATE UNIQUE INDEX idx_users_username_lower\n  ON users(LOWER(username));',
'重複防止+高速化',
ARRAY['UNIQUE制約と同じ効果', '式インデックスも作れる', '部分一意インデックスも可能', 'UNIQUE制約より柔軟'],
'一意性+高速化',
ARRAY['重複を防ぎつつ高速化', 'UNIQUE制約と同じ効果', '式インデックスも可能', 'メールアドレス等に使用'],
true),

('drop-index', 'DROP INDEX', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'インデックス削除',
'DROP INDEXで不要なインデックスを削除します。',
'DROP INDEX idx_users_email;\nDROP INDEX IF EXISTS idx_old_column;\nDROP INDEX CONCURRENTLY idx_large_table; -- PostgreSQL',
'インデックス削除',
ARRAY['削除中はテーブルロック（PostgreSQL以外）', 'CONCURRENTLY（PostgreSQL）でロック回避', '本当に不要か確認しろ', 'PRIMARY KEY, UNIQUEのインデックスは制約削除で'],
'インデックスを削除',
ARRAY['不要なインデックスを削除', '削除中はテーブルがロックされる場合あり', 'IF EXISTSで存在確認', 'PostgreSQLはCONCURRENTLYでロック回避'],
true),

('explain', 'EXPLAIN', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'実行計画を表示',
'EXPLAINでクエリの実行計画を確認し、パフォーマンスを分析します。',
'EXPLAIN SELECT * FROM users WHERE email = ''test@example.com'';\n\n-- 実際に実行して統計も表示\nEXPLAIN ANALYZE SELECT * FROM orders\n  WHERE user_id = 123;\n\n-- MySQLの場合\nEXPLAIN FORMAT=JSON SELECT ...;',
'実行計画分析',
ARRAY['ANALYZEで実際に実行して統計取得', 'Seq Scanは全件スキャン（遅い）', 'Index Scanはインデックス使用（速い）', 'costとrowsに注目'],
'クエリの動作を分析',
ARRAY['クエリがどう実行されるか確認', 'インデックスが使われているか判定', 'EXPLAIN ANALYZEで実際の統計も取得', 'パフォーマンスチューニングの第一歩'],
true),

('analyze', 'ANALYZE', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'統計情報を更新',
'ANALYZEでテーブルの統計情報を更新し、クエリプランナを最適化します。',
'ANALYZE users;\nANALYZE; -- 全テーブル\n\n-- PostgreSQLの詳細統計\nANALYZE VERBOSE users;',
'統計更新',
ARRAY['データ変更後に実行すべき', 'クエリプランナが使う統計を更新', 'VACUUMと一緒にVACUUM ANALYZE', '自動ANALYZEもある'],
'統計情報を更新',
ARRAY['テーブルの統計情報を更新', 'クエリプランナの精度が上がる', '大量のデータ変更後に実行', '自動実行されることも多い'],
true),

('vacuum', 'VACUUM', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'不要領域を回収',
'VACUUM（PostgreSQL）で削除されたレコードの領域を回収します。',
'VACUUM users;\nVACUUM FULL users; -- 完全VACUUM（ロック）\nVACUUM ANALYZE users; -- 統計更新も同時に',
'ゴミ掃除',
ARRAY['PostgreSQL固有', 'VACUUM FULLはテーブルロック', '自動VACUUMが通常は動く', 'ANALYZE併用が定番'],
'不要領域を回収',
ARRAY['削除レコードの領域を回収（PostgreSQL）', 'パフォーマンス維持に必要', 'VACUUM ANALYZEで統計も更新', '自動実行されることが多い'],
true),

('reindex', 'REINDEX', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'インデックス再構築',
'REINDEXでインデックスを再構築し、肥大化を解消します。',
'REINDEX INDEX idx_users_email;\nREINDEX TABLE users;\nREINDEX DATABASE mydb;',
'インデックス再構築',
ARRAY['インデックスの肥大化を解消', 'PostgreSQL固有', 'テーブルロックされる', 'CONCURRENTLY（PG12+）でロック回避'],
'インデックスを再構築',
ARRAY['肥大化したインデックスを再構築', 'PostgreSQL固有', 'パフォーマンス改善', 'ロックが発生するので注意'],
true),

('alter-table', 'ALTER TABLE', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'intermediate',
'テーブル構造を変更',
'ALTER TABLEでテーブルの列追加、削除、変更を行います。',
'-- 列追加\nALTER TABLE users ADD COLUMN bio TEXT;\n\n-- 列削除\nALTER TABLE users DROP COLUMN temp_field;\n\n-- 列名変更\nALTER TABLE users RENAME COLUMN old_name TO new_name;\n\n-- 型変更\nALTER TABLE users ALTER COLUMN age TYPE INTEGER;',
'テーブル改造',
ARRAY['本番環境での変更は慎重に', 'ADD COLUMNは比較的安全', 'DROP COLUMNはデータ消失', '型変更はロックとコスト大'],
'テーブルを変更',
ARRAY['列の追加、削除、変更', '本番環境では慎重に実行', 'マイグレーションツール推奨', 'ダウンタイムに注意'],
true),

('truncate', 'TRUNCATE', '55555555-5555-5555-5555-555555555555', 'b0444444-4444-4444-4444-444444444444', 'syntax', 'beginner',
'テーブルを高速削除',
'TRUNCATEはテーブルの全データを高速に削除します。',
'TRUNCATE TABLE logs;\nTRUNCATE TABLE orders CASCADE; -- 外部キー制約も無視\nTRUNCATE TABLE temp_data RESTART IDENTITY; -- AUTO_INCREMENTリセット',
'全件削除',
ARRAY['DELETE FROM tableより速い', 'ロールバック不可', 'トリガーが動かない', '外部キー制約に注意'],
'全データを高速削除',
ARRAY['テーブルの全データを削除', 'DELETE FROMより高速', 'ロールバック不可', 'AUTO_INCREMENTもリセット可能'],
true);

-- =====================
-- 高度な機能 (15件)
-- =====================
INSERT INTO entries (slug, name, language_id, category_id, entry_type, difficulty, short_desc, full_desc, code_example, sarcastic_title, sarcastic_notes, angel_title, angel_notes, is_published) VALUES

('row-number', 'ROW_NUMBER', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'連番を振る',
'ROW_NUMBERは結果セットに連番を振ります。ページネーションやランキングに使います。',
'SELECT\n  name,\n  price,\n  ROW_NUMBER() OVER (ORDER BY price DESC) AS rank\nFROM products;\n\n-- カテゴリ別の連番\nSELECT\n  name,\n  category,\n  ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS rank_in_category\nFROM products;',
'連番生成',
ARRAY['Window関数の基本', 'PARTITION BYでグループ別連番', '同順位でも連番は続く（1,2,3...）', 'RANKとの違いを理解しろ'],
'連番を付ける',
ARRAY['結果に連番を振る', 'PARTITION BYでグループ別', 'ランキング作成に使う', 'ORDER BYで順序指定'],
true),

('rank-dense-rank', 'RANK / DENSE_RANK', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'順位を付ける',
'RANKとDENSE_RANKは同順位を考慮した順位付け。RANKは飛び番、DENSE_RANKは詰める。',
'SELECT\n  name,\n  score,\n  RANK() OVER (ORDER BY score DESC) AS rank,\n  DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank\nFROM students;\n-- score: 100, 90, 90, 80\n-- RANK:    1,  2,  2,  4  （3が飛ぶ）\n-- DENSE:   1,  2,  2,  3  （詰める）',
'順位付け',
ARRAY['同順位の後の扱いが違う', 'ROW_NUMBERは同順位でも連番', '商品ランキング、成績順位に', 'PARTITION BYでグループ別順位'],
'順位を計算',
ARRAY['RANK: 同順位後は飛び番（1,2,2,4）', 'DENSE_RANK: 詰める（1,2,2,3）', 'ROW_NUMBER: 連番（1,2,3,4）', 'ランキング表示に使う'],
true),

('ntile', 'NTILE', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'N分割したグループ番号',
'NTILEは結果をN個のグループに分割し、グループ番号を振ります。',
'SELECT\n  name,\n  price,\n  NTILE(4) OVER (ORDER BY price) AS quartile\nFROM products;\n-- 価格帯で4分割：1=安, 2=やや安, 3=やや高, 4=高',
'N分割',
ARRAY['四分位、十分位などの作成に', 'データの均等分割', 'ABテストのグループ分けにも', 'グループサイズは自動調整'],
'N個のグループに分割',
ARRAY['結果をN個のグループに分割', '四分位数、十分位数の作成に', 'グループ番号を1〜Nで返す', 'データ分析に便利'],
true),

('lag-lead', 'LAG / LEAD', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'前後の行を参照',
'LAGは前の行、LEADは次の行の値を取得します。',
'SELECT\n  date,\n  sales,\n  LAG(sales) OVER (ORDER BY date) AS prev_sales,\n  LEAD(sales) OVER (ORDER BY date) AS next_sales,\n  sales - LAG(sales) OVER (ORDER BY date) AS diff\nFROM daily_sales;',
'前後参照',
ARRAY['デフォルトは1行前/後、変更可能', '第3引数でNULL時のデフォルト値', '前日比、前年比の計算に', 'PARTITION BYでグループ内参照'],
'前後の行を取得',
ARRAY['LAG: 前の行の値', 'LEAD: 次の行の値', '前日比、増減の計算に便利', 'オフセット指定で何行前後かを変更可'],
true),

('first-last-value', 'FIRST_VALUE / LAST_VALUE', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'最初・最後の値を取得',
'FIRST_VALUEは最初の値、LAST_VALUEは最後の値を取得します。',
'SELECT\n  name,\n  category,\n  price,\n  FIRST_VALUE(price) OVER (\n    PARTITION BY category\n    ORDER BY price\n  ) AS min_price,\n  LAST_VALUE(price) OVER (\n    PARTITION BY category\n    ORDER BY price\n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS max_price\nFROM products;',
'端の値',
ARRAY['LAST_VALUEはフレーム指定に注意', 'デフォルトフレームはCURRENT ROWまで', 'UNBOUNDED FOLLOWINGで全体の最後', 'MIN/MAXより柔軟'],
'先頭・末尾の値',
ARRAY['グループ内の最初/最後の値', 'PARTITION BYでグループ指定', 'LAST_VALUEはフレーム指定が必要', 'カテゴリ内の最小最大値などに'],
true),

('cte-with', 'WITH句（CTE）', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'共通テーブル式',
'WITH句（CTE）で名前付きサブクエリを定義し、可読性を向上させます。',
'WITH high_spenders AS (\n  SELECT user_id, SUM(total) AS total_spent\n  FROM orders\n  GROUP BY user_id\n  HAVING SUM(total) > 10000\n)\nSELECT u.name, hs.total_spent\nFROM users u\nJOIN high_spenders hs ON u.id = hs.user_id;\n\n-- 複数CTE\nWITH\n  active_users AS (...),\n  recent_orders AS (...)\nSELECT ...',
'名前付きサブクエリ',
ARRAY['サブクエリより読みやすい', '複数定義可能', '再帰CTEもある（後述）', 'パフォーマンスは同等'],
'サブクエリに名前をつける',
ARRAY['WITH 名前 AS (クエリ)で定義', 'サブクエリより読みやすい', '複数のCTEを定義可能', '複雑なクエリの整理に最適'],
true),

('recursive-cte', '再帰CTE', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'階層データの再帰処理',
'RECURSIVE CTEで階層構造やグラフを再帰的に処理します。',
'WITH RECURSIVE subordinates AS (\n  -- 基底部：トップの社員\n  SELECT id, name, manager_id, 1 AS level\n  FROM employees\n  WHERE manager_id IS NULL\n  \n  UNION ALL\n  \n  -- 再帰部：部下を取得\n  SELECT e.id, e.name, e.manager_id, s.level + 1\n  FROM employees e\n  JOIN subordinates s ON e.manager_id = s.id\n)\nSELECT * FROM subordinates;',
'再帰クエリ',
ARRAY['組織図、カテゴリツリーに', '無限ループに注意', '基底部とUNION ALL再帰部が必要', 'パフォーマンスに注意'],
'階層を再帰的に処理',
ARRAY['WITH RECURSIVEで再帰処理', '組織図、カテゴリツリーなどに', '基底部と再帰部を定義', '無限ループに注意'],
true),

('window-frame', 'Window Frame', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'Window関数の範囲指定',
'ROWS/RANGEでWindow関数の計算範囲を指定します。',
'SELECT\n  date,\n  sales,\n  -- 直近3日間の合計\n  SUM(sales) OVER (\n    ORDER BY date\n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS rolling_3day,\n  -- 累積合計\n  SUM(sales) OVER (\n    ORDER BY date\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS cumulative\nFROM daily_sales;',
'計算範囲指定',
ARRAY['ROWS（物理行）とRANGE（論理範囲）', 'PRECEDING（前）、FOLLOWING（後）', 'UNBOUNDED（端まで）', '移動平均、累積の定番'],
'計算範囲を指定',
ARRAY['Window関数の計算範囲を制御', 'ROWS BETWEEN ... AND ...', '移動平均、累積合計などに', 'PRECEDINGで前、FOLLOWINGで後を指定'],
true),

('transaction', 'トランザクション', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'複数操作を一括実行',
'BEGIN/COMMITでトランザクションを開始・確定。ROLLBACKで取り消し。',
'BEGIN;\n\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n\nCOMMIT;\n\n-- エラー時はロールバック\nBEGIN;\nINSERT INTO orders (user_id, total) VALUES (1, 1000);\n-- エラー発生\nROLLBACK;',
'ACID保証',
ARRAY['Atomicity（原子性）を保証', 'COMMITで確定、ROLLBACKで取り消し', 'ロック競合に注意', 'ネストしたトランザクションは非対応（SAVEPOINT使用）'],
'複数操作をまとめる',
ARRAY['BEGIN〜COMMIT で一連の操作', '途中でエラーならROLLBACK', '銀行振込のような操作に必須', '全て成功するか全て失敗するかのどちらか'],
true),

('isolation-level', '分離レベル', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'トランザクションの分離度',
'分離レベルで同時実行トランザクション間の可視性を制御します。',
'-- PostgreSQL\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n\n-- MySQL\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;',
'同時実行制御',
ARRAY['READ UNCOMMITTED（ダーティリード）', 'READ COMMITTED（デフォルト）', 'REPEATABLE READ', 'SERIALIZABLE（最厳格）'],
'同時実行の制御',
ARRAY['トランザクション間の干渉を制御', 'レベルが高いほど厳格だが遅い', 'READ COMMITTEDが一般的', 'SERIALIZABLEは直列化相当'],
true),

('lock', 'ロック', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'行・テーブルのロック',
'明示的にロックを取得して排他制御を行います。',
'-- 行ロック\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n\n-- 共有ロック（読み取り専用）\nSELECT * FROM products WHERE id = 1 FOR SHARE;\n\n-- テーブルロック\nLOCK TABLE products IN EXCLUSIVE MODE;',
'排他制御',
ARRAY['FOR UPDATEで行ロック', 'FOR SHAREで共有ロック', 'デッドロック注意', '長時間ロックは禁物'],
'排他制御',
ARRAY['FOR UPDATEで行をロック', '他のトランザクションの書き込みを防ぐ', 'デッドロックに注意', '在庫引き当て等で使用'],
true),

('materialized-view', 'マテリアライズドビュー', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'advanced',
'結果を物理的に保存',
'マテリアライズドビューはクエリ結果を物理的に保存し、高速アクセスを実現します。',
'CREATE MATERIALIZED VIEW sales_summary AS\nSELECT\n  DATE_TRUNC(''month'', created_at) AS month,\n  SUM(total) AS total_sales\nFROM orders\nGROUP BY month;\n\n-- 更新\nREFRESH MATERIALIZED VIEW sales_summary;',
'結果のキャッシュ',
ARRAY['PostgreSQL, Oracleなどで対応', '重い集計クエリの結果を保存', '手動でREFRESH必要', 'MySQLは未対応'],
'クエリ結果を保存',
ARRAY['複雑なクエリ結果を物理保存', '参照は高速だが更新が必要', 'REFRESH MATERIALIZED VIEWで更新', '集計レポート等に便利'],
true),

('view', 'VIEW', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'仮想テーブル',
'VIEWはクエリに名前をつけて再利用可能にします。',
'CREATE VIEW active_users AS\nSELECT id, name, email\nFROM users\nWHERE status = ''active'';\n\n-- 使用\nSELECT * FROM active_users;\n\n-- 削除\nDROP VIEW active_users;',
'クエリの再利用',
ARRAY['複雑なクエリを簡略化', '権限制御にも使える', '更新可能ビューもある', 'パフォーマンスは元クエリと同じ'],
'クエリに名前をつける',
ARRAY['複雑なクエリを簡潔に書ける', 'テーブルのように扱える', '実際のデータは保存されない', '権限管理にも便利'],
true),

('prepared-statement', 'プリペアドステートメント', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'syntax', 'intermediate',
'SQLインジェクション対策',
'プリペアドステートメントでパラメータ化し、SQLインジェクションを防ぎます。',
'-- PostgreSQL\nPREPARE get_user (INTEGER) AS\n  SELECT * FROM users WHERE id = $1;\nEXECUTE get_user(123);\nDEALLOCATE get_user;\n\n-- アプリケーション側（擬似コード）\nstmt = db.prepare("SELECT * FROM users WHERE id = ?")\nstmt.execute([user_id])',
'安全なクエリ',
ARRAY['SQLインジェクション対策の基本', 'プレースホルダで値を分離', '実行計画キャッシュも', 'ORMは内部でこれを使う'],
'安全なクエリ実行',
ARRAY['SQLインジェクション対策', 'プレースホルダで値を埋め込む', '実行計画の再利用も可能', 'セキュリティの基本'],
true),

('json-functions', 'JSON関数', '55555555-5555-5555-5555-555555555555', 'b0555555-5555-5555-5555-555555555555', 'function', 'intermediate',
'JSON操作',
'JSON型の操作・抽出関数。NoSQLライクな操作が可能。',
'-- PostgreSQL\nSELECT data->>''name'' AS name FROM users;\nSELECT data->''address''->''city'' AS city FROM users;\nSELECT * FROM users WHERE data @> ''{"status": "active"}'';\n\n-- MySQL\nSELECT JSON_EXTRACT(data, ''$.name'') FROM users;\nSELECT * FROM users WHERE JSON_CONTAINS(data, ''"active"'', ''$.status'');',
'JSON操作',
ARRAY['->はJSONを返す、->>はテキストを返す', '@>で包含判定（PostgreSQL）', 'インデックスも作れる（GIN）', 'JSON_TABLE（MySQL8+）で展開'],
'JSON型を操作',
ARRAY['JSON型の値を抽出・操作', '->や->>で階層アクセス', '@>で包含判定', 'NoSQLライクな柔軟性'],
true);
